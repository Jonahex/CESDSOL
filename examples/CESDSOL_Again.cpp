// CESDSOL_Again.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "Math/MKL/FGMRES.h"
#include "Math/MKL/ILU0.h"
#include "Math/MKL/ILUT.h"
#include "Math/MKL/PARDISO.h"
#include "Math/Concepts.h"
#include "Math/GoldenSectionSearch.h"
#include "Math/ModifiedNewton.h"
#include "Math/MultiLevelArray.h"
#include "Math/ODE/RungeKuttaSolver.h"
#include "Math/ODE/Tables/Verner87.h"
#include "Math/TrivialLineSearcher.h"
#include "Math/VectorOperations.h"
#include "Grid/DirectProductGrid.h"
#include "Discretization/StructuredFiniteDifferenceDiscretization.h"
#include "ParametricSweep/AdaptiveParametricSweeper.h"
#include "ParametricSweep/FixedStepParametricSweeper.h"
#include "Problem/SimplifiedInterface.h"
#include "Problem/ExplicitTransientProblem.h"
#include "Problem/StationaryProblem.h"
#include "Serialization/Serializer.h"

#include <chrono>
#include <fstream>
#include <iostream>
#include <vector>

using namespace CESDSOL;

int main()
{
    auto descriptor = StationaryProblemDescriptor<2, double, double>(GridDescriptor<2, double>(5), Array<Array<std::array<size_t, 2>>>{ { {0, 1}, { 0, 2 }, { 1, 0 }, { 2, 0 }}, { {0, 2}, {1, 0}, {2, 0}, {0, 1} }, { {0, 1}, {1, 0}, {0, 2}, {2, 0} }, { {0, 1}, {1, 0}, {0, 2}, {2, 0} }, { {0, 1}, {1, 0} }, { {0, 1}, {1, 0} }, { {1, 0}, {0, 1} }, { {1, 0}, {0, 1} }, { {0, 1}, {1, 0}, {0, 2}, {2, 0} }, { {0, 1}, {1, 0}, {0, 2}, {2, 0} }}, 10, 6, 0, 0, 0, 1, 0, 0, 0, 0);
    descriptor.SetProblemName("FermiMaxwell");
    descriptor.SetParameterName(0, "con");
    descriptor.SetParameterName(1, "alfa");
    descriptor.SetParameterName(2, "w");
    descriptor.SetParameterName(3, "q");
    descriptor.SetParameterName(4, "nr");
    descriptor.SetParameterName(5, "mu");
    descriptor.SetVariableName(0, "F0");
    descriptor.SetVariableName(1, "F1");
    descriptor.SetVariableName(2, "F2");
    descriptor.SetVariableName(3, "W");
    descriptor.SetVariableName(4, "X");
    descriptor.SetVariableName(5, "Y");
    descriptor.SetVariableName(6, "P");
    descriptor.SetVariableName(7, "Q");
    descriptor.SetVariableName(8, "Afi");
    descriptor.SetVariableName(9, "V");
    descriptor.SetLocalVariableIndependentExpression(0, [](const auto& l, const auto& g) {return (g.Parameters[0] * l.Point[0]) / (1 - l.Point[0]); });
    descriptor.SetContinuousEquation(0, 0, [](const auto& l, const auto& g) {return -0.5 * (pow(E, -2 * l.FieldValues[0] + 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 4) * (pow(l.DerivativeValues[3][0], 2) + pow(l.FieldValues[3] - (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) / g.Parameters[0], 2))) - (pow(g.Parameters[1], 2) * (2 * pow(l.FieldValues[8], 2) * (pow(E, 2 * l.FieldValues[0]) + pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2)) + 4 * l.FieldValues[8] * sin(l.Point[1]) * (-(pow(E, l.FieldValues[0] + 2 * (l.FieldValues[1] + l.FieldValues[2])) * g.Parameters[3] * pow(l.FieldValues[6], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[3]) - pow(E, l.FieldValues[0] + 2 * (l.FieldValues[1] + l.FieldValues[2])) * g.Parameters[3] * pow(l.FieldValues[7], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] + 2 * pow(E, 2 * l.FieldValues[0] + 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[3] * l.FieldValues[7] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[4] - pow(E, l.FieldValues[0] + 2 * (l.FieldValues[1] + l.FieldValues[2])) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * pow(l.FieldValues[4], 2) - 2 * pow(E, 2 * l.FieldValues[0] + 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[3] * l.FieldValues[6] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[5] - pow(E, l.FieldValues[0] + 2 * (l.FieldValues[1] + l.FieldValues[2])) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * pow(l.FieldValues[5], 2) + pow(E, 2 * l.FieldValues[0]) * cos(l.Point[1]) * l.DerivativeValues[8][0] + pow(E, 2 * l.FieldValues[2]) * cos(l.Point[1]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) * l.DerivativeValues[8][0] + pow(E, 2 * l.FieldValues[2]) * cos(l.Point[1]) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[9][0] + (pow(E, 2 * l.FieldValues[0]) * pow(1 - l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.DerivativeValues[8][1]) / g.Parameters[0] + (pow(E, 2 * l.FieldValues[2]) * pow(1 - l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 3) * pow(l.FieldValues[3], 2) * l.DerivativeValues[8][1]) / g.Parameters[0] + (pow(E, 2 * l.FieldValues[2]) * pow(1 - l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.DerivativeValues[9][1]) / g.Parameters[0]) + sin(l.Point[1]) * (-(pow(E, l.FieldValues[0] + l.FieldValues[1] + 2 * l.FieldValues[2]) * pow(l.FieldValues[6], 2) * l.VIEValues[0] * sin(l.Point[1]) * (-4 * pow(E, l.FieldValues[1]) * g.Parameters[2] * l.VIEValues[0] + 4 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.VIEValues[0] * l.FieldValues[9] + 4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0])) - pow(E, l.FieldValues[0] + l.FieldValues[1] + 2 * l.FieldValues[2]) * pow(l.FieldValues[7], 2) * l.VIEValues[0] * sin(l.Point[1]) * (-4 * pow(E, l.FieldValues[1]) * g.Parameters[2] * l.VIEValues[0] + 4 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.VIEValues[0] * l.FieldValues[9] + 4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) + 2 * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[6] * l.VIEValues[0] * (-(pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.FieldValues[4]) - 4 * pow(E, l.FieldValues[0] + l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[5] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (-2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[5][0] - (2 * pow(E, l.FieldValues[0]) * pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[7][0]) / g.Parameters[0] + (pow(E, l.FieldValues[2]) * pow(1 - l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[4] * l.DerivativeValues[3][1]) / g.Parameters[0])) + 2 * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[7] * l.VIEValues[0] * (4 * pow(E, l.FieldValues[0] + l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[4] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[3] * l.FieldValues[5] - 2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[4][0] - (2 * pow(E, l.FieldValues[0]) * pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[6][0]) / g.Parameters[0] - (pow(E, l.FieldValues[2]) * pow(1 - l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[5] * l.DerivativeValues[3][1]) / g.Parameters[0])) + sin(l.Point[1]) * (pow(E, l.FieldValues[0] + l.FieldValues[1] + 2 * l.FieldValues[2]) * l.VIEValues[0] * pow(l.FieldValues[4], 2) * (4 * pow(E, l.FieldValues[1]) * g.Parameters[2] * l.VIEValues[0] - 4 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.VIEValues[0] * l.FieldValues[9] - 4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) + pow(E, l.FieldValues[0] + l.FieldValues[1] + 2 * l.FieldValues[2]) * l.VIEValues[0] * pow(l.FieldValues[5], 2) * (4 * pow(E, l.FieldValues[1]) * g.Parameters[2] * l.VIEValues[0] - 4 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.VIEValues[0] * l.FieldValues[9] - 4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) + 2 * ((pow(E, 2 * l.FieldValues[0]) + pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2)) * pow(l.DerivativeValues[8][0], 2) + 2 * pow(E, 2 * l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] * l.DerivativeValues[9][0] + pow(E, 2 * l.FieldValues[2]) * pow(l.DerivativeValues[9][0], 2) + pow(l.VIEValues[0], 2) * ((pow(1 - l.Point[0], 4) * (pow(E, 2 * l.FieldValues[0]) + pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2)) * pow(l.DerivativeValues[8][1], 2)) / pow(g.Parameters[0], 2) + (2 * pow(E, 2 * l.FieldValues[2]) * pow(1 - l.Point[0], 4) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] * l.DerivativeValues[9][1]) / pow(g.Parameters[0], 2) + (pow(E, 2 * l.FieldValues[2]) * pow(1 - l.Point[0], 4) * pow(l.DerivativeValues[9][1], 2)) / pow(g.Parameters[0], 2))) - 4 * pow(E, 2 * l.FieldValues[0] + l.FieldValues[1] + 2 * l.FieldValues[2]) * l.VIEValues[0] * l.FieldValues[5] * (-l.DerivativeValues[6][1] + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[4][1]) / g.Parameters[0]) + 4 * pow(E, 2 * l.FieldValues[0] + l.FieldValues[1] + 2 * l.FieldValues[2]) * l.VIEValues[0] * l.FieldValues[4] * (-l.DerivativeValues[7][1] + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[5][1]) / g.Parameters[0]))))) / (2. * pow(E, 2 * (l.FieldValues[0] + l.FieldValues[2]))) + sin(l.Point[1]) * (cos(l.Point[1]) * l.DerivativeValues[0][0] + sin(l.Point[1]) * (l.DerivativeValues[0][0] * (l.DerivativeValues[0][0] + l.DerivativeValues[2][0]) + l.DerivativeValues[0][1] + l.VIEValues[0] * ((pow(1 - l.Point[0], 2) * l.DerivativeValues[0][2] * (2 + l.VIEValues[0] * ((pow(1 - l.Point[0], 2) * l.DerivativeValues[0][2]) / g.Parameters[0] + (pow(1 - l.Point[0], 2) * l.DerivativeValues[2][1]) / g.Parameters[0]))) / g.Parameters[0] + (l.VIEValues[0] * (-2 * pow(1 - l.Point[0], 3) * l.DerivativeValues[0][2] + pow(1 - l.Point[0], 4) * l.DerivativeValues[0][3])) / pow(g.Parameters[0], 2)))); });
    descriptor.SetContinuousEquation(0, 1, [](const auto& l, const auto& g) {return l.DerivativeValues[0][2]; });
    descriptor.SetContinuousEquation(0, 2, [](const auto& l, const auto& g) {return l.FieldValues[0]; });
    descriptor.SetContinuousEquation(0, 3, [](const auto& l, const auto& g) {return l.DerivativeValues[0][0]; });
    descriptor.SetContinuousEquation(0, 4, [](const auto& l, const auto& g) {return l.DerivativeValues[0][0]; });
    descriptor.SetContinuousEquation(1, 0, [](const auto& l, const auto& g) {return -0.5 * (pow(g.Parameters[1], 2) * pow(E, -l.FieldValues[0] + l.FieldValues[1] - l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * (-(pow(E, l.FieldValues[2]) * pow(l.FieldValues[6], 2) * sin(l.Point[1]) * (4 * pow(E, l.FieldValues[1]) * g.Parameters[2] * l.VIEValues[0] - 4 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.VIEValues[0] * l.FieldValues[9] - 4 * pow(E, l.FieldValues[1]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[3] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0])) - pow(E, l.FieldValues[2]) * pow(l.FieldValues[7], 2) * sin(l.Point[1]) * (4 * pow(E, l.FieldValues[1]) * g.Parameters[2] * l.VIEValues[0] - 4 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.VIEValues[0] * l.FieldValues[9] - 4 * pow(E, l.FieldValues[1]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[3] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) + l.FieldValues[6] * (-2 * pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.FieldValues[4] - 8 * pow(E, l.FieldValues[0] + l.FieldValues[1]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[5] + 2 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[5][0] + (2 * pow(E, l.FieldValues[0]) * pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[7][0]) / g.Parameters[0] + (pow(E, l.FieldValues[2]) * pow(1 - l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[4] * l.DerivativeValues[3][1]) / g.Parameters[0])) + 2 * l.FieldValues[7] * (4 * pow(E, l.FieldValues[0] + l.FieldValues[1]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[4] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[3] * l.FieldValues[5] + 2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[4][0] + (2 * pow(E, l.FieldValues[0]) * pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[6][0]) / g.Parameters[0] - (pow(E, l.FieldValues[2]) * pow(1 - l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[5] * l.DerivativeValues[3][1]) / g.Parameters[0])) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (pow(l.FieldValues[4], 2) * (-4 * pow(E, l.FieldValues[1]) * g.Parameters[2] * l.VIEValues[0] + 4 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.VIEValues[0] * l.FieldValues[9] + 4 * pow(E, l.FieldValues[1]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[3] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) - l.FieldValues[5] * (l.FieldValues[5] * (4 * pow(E, l.FieldValues[1]) * g.Parameters[2] * l.VIEValues[0] - 4 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.VIEValues[0] * l.FieldValues[9] - 4 * pow(E, l.FieldValues[1]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[3] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) + 4 * pow(E, l.FieldValues[0]) * (l.DerivativeValues[6][1] - (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[4][1]) / g.Parameters[0])) + 4 * pow(E, l.FieldValues[0]) * l.FieldValues[4] * (l.DerivativeValues[7][1] - (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[5][1]) / g.Parameters[0])))) + (-(pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 4) * (pow(l.DerivativeValues[3][0], 2) + pow(l.FieldValues[3] - (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) / g.Parameters[0], 2))) - 4 * pow(E, 2 * l.FieldValues[0]) * pow(sin(l.Point[1]), 2) * (l.DerivativeValues[0][0] * (cot(l.Point[1]) + l.DerivativeValues[2][0]) - l.DerivativeValues[1][0] + l.VIEValues[0] * (-((pow(1 - l.Point[0], 2) * l.DerivativeValues[1][1]) / g.Parameters[0]) + (pow(1 - l.Point[0], 2) * l.DerivativeValues[0][2] * (1 + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[2][1]) / g.Parameters[0])) / g.Parameters[0] - (l.VIEValues[0] * (-2 * pow(1 - l.Point[0], 3) * l.DerivativeValues[1][1] + pow(1 - l.Point[0], 4) * l.DerivativeValues[1][2])) / pow(g.Parameters[0], 2)))) / (4. * pow(E, 2 * l.FieldValues[0])); });
    descriptor.SetContinuousEquation(1, 1, [](const auto& l, const auto& g) {return l.DerivativeValues[1][1]; });
    descriptor.SetContinuousEquation(1, 2, [](const auto& l, const auto& g) {return l.FieldValues[1]; });
    descriptor.SetContinuousEquation(1, 3, [](const auto& l, const auto& g) {return l.FieldValues[1] - l.FieldValues[2]; });
    descriptor.SetContinuousEquation(1, 4, [](const auto& l, const auto& g) {return l.FieldValues[1] - l.FieldValues[2]; });
    descriptor.SetContinuousEquation(2, 0, [](const auto& l, const auto& g) {return (pow(g.Parameters[1], 2) * (2 * pow(l.FieldValues[8], 2) * (pow(E, 2 * l.FieldValues[0]) + pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2)) + 4 * l.FieldValues[8] * sin(l.Point[1]) * (-(pow(E, l.FieldValues[0] + 2 * (l.FieldValues[1] + l.FieldValues[2])) * g.Parameters[3] * pow(l.FieldValues[6], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[3]) - pow(E, l.FieldValues[0] + 2 * (l.FieldValues[1] + l.FieldValues[2])) * g.Parameters[3] * pow(l.FieldValues[7], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] + 2 * pow(E, 2 * l.FieldValues[0] + 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[3] * l.FieldValues[7] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[4] - pow(E, l.FieldValues[0] + 2 * (l.FieldValues[1] + l.FieldValues[2])) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * pow(l.FieldValues[4], 2) - 2 * pow(E, 2 * l.FieldValues[0] + 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[3] * l.FieldValues[6] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[5] - pow(E, l.FieldValues[0] + 2 * (l.FieldValues[1] + l.FieldValues[2])) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * pow(l.FieldValues[5], 2) + pow(E, 2 * l.FieldValues[0]) * cos(l.Point[1]) * l.DerivativeValues[8][0] + pow(E, 2 * l.FieldValues[2]) * cos(l.Point[1]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) * l.DerivativeValues[8][0] + pow(E, 2 * l.FieldValues[2]) * cos(l.Point[1]) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[9][0] + (pow(E, 2 * l.FieldValues[0]) * pow(1 - l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.DerivativeValues[8][1]) / g.Parameters[0] + (pow(E, 2 * l.FieldValues[2]) * pow(1 - l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 3) * pow(l.FieldValues[3], 2) * l.DerivativeValues[8][1]) / g.Parameters[0] + (pow(E, 2 * l.FieldValues[2]) * pow(1 - l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.DerivativeValues[9][1]) / g.Parameters[0]) + sin(l.Point[1]) * (-(pow(E, l.FieldValues[0] + l.FieldValues[1] + 2 * l.FieldValues[2]) * pow(l.FieldValues[6], 2) * l.VIEValues[0] * sin(l.Point[1]) * (-4 * pow(E, l.FieldValues[1]) * g.Parameters[2] * l.VIEValues[0] + 4 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.VIEValues[0] * l.FieldValues[9] + 4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] + 3 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0])) - pow(E, l.FieldValues[0] + l.FieldValues[1] + 2 * l.FieldValues[2]) * pow(l.FieldValues[7], 2) * l.VIEValues[0] * sin(l.Point[1]) * (-4 * pow(E, l.FieldValues[1]) * g.Parameters[2] * l.VIEValues[0] + 4 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.VIEValues[0] * l.FieldValues[9] + 4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] + 3 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) + 2 * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[6] * l.VIEValues[0] * (-3 * pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.FieldValues[4] - 4 * pow(E, l.FieldValues[0] + l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[5] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[5][0] + (2 * pow(E, l.FieldValues[0]) * pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[7][0]) / g.Parameters[0] + (3 * pow(E, l.FieldValues[2]) * pow(1 - l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[4] * l.DerivativeValues[3][1]) / g.Parameters[0])) + 2 * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[7] * l.VIEValues[0] * (4 * pow(E, l.FieldValues[0] + l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[4] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (3 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[3] * l.FieldValues[5] + 2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[4][0] + (2 * pow(E, l.FieldValues[0]) * pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[6][0]) / g.Parameters[0] - (3 * pow(E, l.FieldValues[2]) * pow(1 - l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[5] * l.DerivativeValues[3][1]) / g.Parameters[0])) + sin(l.Point[1]) * (pow(E, l.FieldValues[0] + l.FieldValues[1] + 2 * l.FieldValues[2]) * l.VIEValues[0] * pow(l.FieldValues[4], 2) * (4 * pow(E, l.FieldValues[1]) * g.Parameters[2] * l.VIEValues[0] - 4 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.VIEValues[0] * l.FieldValues[9] - 4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] + 3 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) + pow(E, l.FieldValues[0] + l.FieldValues[1] + 2 * l.FieldValues[2]) * l.VIEValues[0] * pow(l.FieldValues[5], 2) * (4 * pow(E, l.FieldValues[1]) * g.Parameters[2] * l.VIEValues[0] - 4 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.VIEValues[0] * l.FieldValues[9] - 4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] + 3 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) + 2 * ((pow(E, 2 * l.FieldValues[0]) + pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2)) * pow(l.DerivativeValues[8][0], 2) + 2 * pow(E, 2 * l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] * l.DerivativeValues[9][0] + pow(E, 2 * l.FieldValues[2]) * pow(l.DerivativeValues[9][0], 2) + pow(l.VIEValues[0], 2) * ((pow(1 - l.Point[0], 4) * (pow(E, 2 * l.FieldValues[0]) + pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2)) * pow(l.DerivativeValues[8][1], 2)) / pow(g.Parameters[0], 2) + (2 * pow(E, 2 * l.FieldValues[2]) * pow(1 - l.Point[0], 4) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] * l.DerivativeValues[9][1]) / pow(g.Parameters[0], 2) + (pow(E, 2 * l.FieldValues[2]) * pow(1 - l.Point[0], 4) * pow(l.DerivativeValues[9][1], 2)) / pow(g.Parameters[0], 2))) + 4 * pow(E, 2 * l.FieldValues[0] + l.FieldValues[1] + 2 * l.FieldValues[2]) * l.VIEValues[0] * l.FieldValues[5] * (-l.DerivativeValues[6][1] + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[4][1]) / g.Parameters[0]) - 4 * pow(E, 2 * l.FieldValues[0] + l.FieldValues[1] + 2 * l.FieldValues[2]) * l.VIEValues[0] * l.FieldValues[4] * (-l.DerivativeValues[7][1] + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[5][1]) / g.Parameters[0]))))) / (2. * pow(E, 2 * (l.FieldValues[0] + l.FieldValues[2]))) + (pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 4) * (pow(l.DerivativeValues[3][0], 2) + pow(l.FieldValues[3] - (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) / g.Parameters[0], 2)) + 2 * pow(E, 2 * l.FieldValues[0]) * sin(l.Point[1]) * (2 * cos(l.Point[1]) * l.DerivativeValues[2][0] + l.DerivativeValues[0][0] * (cos(l.Point[1]) + sin(l.Point[1]) * l.DerivativeValues[2][0]) + sin(l.Point[1]) * (pow(l.DerivativeValues[2][0], 2) + l.DerivativeValues[2][2] + l.VIEValues[0] * ((pow(1 - l.Point[0], 2) * l.DerivativeValues[0][2] * (1 + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[2][1]) / g.Parameters[0])) / g.Parameters[0] + (pow(1 - l.Point[0], 2) * l.DerivativeValues[2][1] * (3 + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[2][1]) / g.Parameters[0])) / g.Parameters[0] + (l.VIEValues[0] * (-2 * pow(1 - l.Point[0], 3) * l.DerivativeValues[2][1] + pow(1 - l.Point[0], 4) * l.DerivativeValues[2][3])) / pow(g.Parameters[0], 2))))) / (2. * pow(E, 2 * l.FieldValues[0])); });
    descriptor.SetContinuousEquation(2, 1, [](const auto& l, const auto& g) {return l.DerivativeValues[2][1]; });
    descriptor.SetContinuousEquation(2, 2, [](const auto& l, const auto& g) {return l.FieldValues[2]; });
    descriptor.SetContinuousEquation(2, 3, [](const auto& l, const auto& g) {return l.DerivativeValues[2][0]; });
    descriptor.SetContinuousEquation(2, 4, [](const auto& l, const auto& g) {return l.DerivativeValues[2][0]; });
    descriptor.SetContinuousEquation(3, 0, [](const auto& l, const auto& g) {return (2 * pow(g.Parameters[1], 2) * (-2 * pow(l.FieldValues[8], 2) * l.FieldValues[3] + 2 * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[4] * l.VIEValues[0] * pow(l.FieldValues[4], 2) + pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * cos(l.Point[1]) * l.VIEValues[0] * pow(l.FieldValues[4], 2) + 2 * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * pow(l.FieldValues[4], 2) + 2 * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[4] * l.VIEValues[0] * pow(l.FieldValues[5], 2) + pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * cos(l.Point[1]) * l.VIEValues[0] * pow(l.FieldValues[5], 2) + 2 * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * pow(l.FieldValues[5], 2) - 2 * l.FieldValues[8] * sin(2 * l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] - l.FieldValues[3] * pow(l.DerivativeValues[8][0], 2) + cos(2 * l.Point[1]) * l.FieldValues[3] * pow(l.DerivativeValues[8][0], 2) - pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * pow(l.FieldValues[4], 2) * l.DerivativeValues[0][0] - pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * pow(l.FieldValues[5], 2) * l.DerivativeValues[0][0] + pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * pow(l.FieldValues[4], 2) * l.DerivativeValues[2][0] + pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * pow(l.FieldValues[5], 2) * l.DerivativeValues[2][0] + pow(E, l.FieldValues[0] + l.FieldValues[1]) * pow(l.FieldValues[6], 2) * l.VIEValues[0] * (2 * pow(E, l.FieldValues[1]) * g.Parameters[4] - pow(E, l.FieldValues[2]) * cos(l.Point[1]) + 2 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[0][0] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[2][0]) + pow(E, l.FieldValues[0] + l.FieldValues[1]) * pow(l.FieldValues[7], 2) * l.VIEValues[0] * (2 * pow(E, l.FieldValues[1]) * g.Parameters[4] - pow(E, l.FieldValues[2]) * cos(l.Point[1]) + 2 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[0][0] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[2][0]) - 2 * l.FieldValues[8] * cos(l.Point[1]) * l.DerivativeValues[9][0] - 2 * sin(l.Point[1]) * l.DerivativeValues[8][0] * l.DerivativeValues[9][0] - (2 * pow(1 - l.Point[0], 2) * l.FieldValues[8] * l.VIEValues[0] * l.FieldValues[3] * l.DerivativeValues[8][1]) / g.Parameters[0] + (2 * pow(1 - l.Point[0], 2) * l.FieldValues[8] * cos(2 * l.Point[1]) * l.VIEValues[0] * l.FieldValues[3] * l.DerivativeValues[8][1]) / g.Parameters[0] - (pow(1 - l.Point[0], 4) * pow(l.VIEValues[0], 2) * l.FieldValues[3] * pow(l.DerivativeValues[8][1], 2)) / pow(g.Parameters[0], 2) + (pow(1 - l.Point[0], 4) * cos(2 * l.Point[1]) * pow(l.VIEValues[0], 2) * l.FieldValues[3] * pow(l.DerivativeValues[8][1], 2)) / pow(g.Parameters[0], 2) + 2 * pow(E, l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[6] * l.VIEValues[0] * sin(l.Point[1]) * (-2 * pow(E, l.FieldValues[1]) * (g.Parameters[2] * l.VIEValues[0] - g.Parameters[3] * l.VIEValues[0] * l.FieldValues[9] - (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[3]) * l.FieldValues[5] - pow(E, l.FieldValues[0]) * l.FieldValues[4] * (-1 + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[0][2]) / g.Parameters[0] - (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[2][1]) / g.Parameters[0])) - 2 * pow(E, l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[7] * l.VIEValues[0] * sin(l.Point[1]) * (-2 * pow(E, l.FieldValues[1]) * (g.Parameters[2] * l.VIEValues[0] - g.Parameters[3] * l.VIEValues[0] * l.FieldValues[9] - (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[3]) * l.FieldValues[4] + pow(E, l.FieldValues[0]) * l.FieldValues[5] * (-1 + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[0][2]) / g.Parameters[0] - (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[2][1]) / g.Parameters[0])) - (2 * pow(1 - l.Point[0], 2) * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) * l.DerivativeValues[9][1]) / g.Parameters[0] - (2 * pow(1 - l.Point[0], 4) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.DerivativeValues[8][1] * l.DerivativeValues[9][1]) / pow(g.Parameters[0], 2))) / pow(E, 2 * l.FieldValues[2]) + sin(l.Point[1]) * (3 * cos(l.Point[1]) * l.DerivativeValues[3][0] + sin(l.Point[1]) * ((-l.DerivativeValues[0][0] + 3 * l.DerivativeValues[2][0]) * l.DerivativeValues[3][0] + l.DerivativeValues[3][2] + (-2 + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[0][2]) / g.Parameters[0] - (3 * pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[2][1]) / g.Parameters[0]) * (l.FieldValues[3] - (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) / g.Parameters[0]) + (pow(l.VIEValues[0], 2) * (-2 * pow(1 - l.Point[0], 3) * l.DerivativeValues[3][1] + pow(1 - l.Point[0], 4) * l.DerivativeValues[3][3])) / pow(g.Parameters[0], 2))); });
    descriptor.SetContinuousEquation(3, 1, [](const auto& l, const auto& g) {return l.FieldValues[3]; });
    descriptor.SetContinuousEquation(3, 2, [](const auto& l, const auto& g) {return l.FieldValues[2]; });
    descriptor.SetContinuousEquation(3, 3, [](const auto& l, const auto& g) {return l.DerivativeValues[3][0]; });
    descriptor.SetContinuousEquation(3, 4, [](const auto& l, const auto& g) {return l.DerivativeValues[3][0]; });
    descriptor.SetContinuousEquation(4, 0, [](const auto& l, const auto& g) {return -0.5 * (cos(l.Point[1]) * l.FieldValues[6]) + pow(E, l.FieldValues[1]) * ((g.Parameters[4] * l.FieldValues[6]) / pow(E, l.FieldValues[2]) + g.Parameters[5] * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[4] + (sin(l.Point[1]) * (g.Parameters[2] * l.VIEValues[0] - g.Parameters[4] * l.FieldValues[3]) * l.FieldValues[5]) / pow(E, l.FieldValues[0])) + pow(E, l.FieldValues[1]) * g.Parameters[3] * l.VIEValues[0] * sin(l.Point[1]) * ((l.FieldValues[8] * l.FieldValues[6]) / pow(E, l.FieldValues[2]) - ((l.FieldValues[9] + l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) * l.FieldValues[5]) / pow(E, l.FieldValues[0])) + (pow(E, -l.FieldValues[0] + l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * (l.FieldValues[5] * l.DerivativeValues[3][0] + l.FieldValues[7] * (-l.FieldValues[3] + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) / g.Parameters[0]))) / 4. + sin(l.Point[1]) * (l.FieldValues[4] - (l.FieldValues[6] * (l.DerivativeValues[0][0] + l.DerivativeValues[1][3] + l.DerivativeValues[2][0])) / 2. - l.DerivativeValues[6][1] + (l.VIEValues[0] * l.FieldValues[4] * ((pow(1 - l.Point[0], 2) * l.DerivativeValues[0][2]) / g.Parameters[0] + (pow(1 - l.Point[0], 2) * l.DerivativeValues[1][1]) / g.Parameters[0] + (pow(1 - l.Point[0], 2) * l.DerivativeValues[2][1]) / g.Parameters[0])) / 2. + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[4][1]) / g.Parameters[0]); });
    descriptor.SetContinuousEquation(4, 1, [](const auto& l, const auto& g) {return l.DerivativeValues[4][1]; });
    descriptor.SetContinuousEquation(4, 2, [](const auto& l, const auto& g) {return l.FieldValues[4]; });
    descriptor.SetContinuousEquation(4, 3, [](const auto& l, const auto& g) {return l.FieldValues[4]; });
    descriptor.SetContinuousEquation(4, 4, [](const auto& l, const auto& g) {return l.DerivativeValues[4][0]; });
    descriptor.SetContinuousEquation(5, 0, [](const auto& l, const auto& g) {return -0.5 * (cos(l.Point[1]) * l.FieldValues[7]) - pow(E, l.FieldValues[1]) * g.Parameters[3] * l.VIEValues[0] * sin(l.Point[1]) * (-((l.FieldValues[8] * l.FieldValues[7]) / pow(E, l.FieldValues[2])) - ((l.FieldValues[9] + l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) * l.FieldValues[4]) / pow(E, l.FieldValues[0])) + pow(E, l.FieldValues[1]) * ((g.Parameters[4] * l.FieldValues[7]) / pow(E, l.FieldValues[2]) - (sin(l.Point[1]) * (g.Parameters[2] * l.VIEValues[0] - g.Parameters[4] * l.FieldValues[3]) * l.FieldValues[4]) / pow(E, l.FieldValues[0]) - g.Parameters[5] * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[5]) - (pow(E, -l.FieldValues[0] + l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * (l.FieldValues[4] * l.DerivativeValues[3][0] + l.FieldValues[6] * (-l.FieldValues[3] + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) / g.Parameters[0]))) / 4. + sin(l.Point[1]) * (l.FieldValues[5] - (l.FieldValues[7] * (l.DerivativeValues[0][0] + l.DerivativeValues[1][3] + l.DerivativeValues[2][0])) / 2. - l.DerivativeValues[7][1] + (l.VIEValues[0] * ((pow(1 - l.Point[0], 2) * l.FieldValues[5] * l.DerivativeValues[0][2]) / g.Parameters[0] + (pow(1 - l.Point[0], 2) * l.FieldValues[5] * l.DerivativeValues[1][1]) / g.Parameters[0] + (pow(1 - l.Point[0], 2) * l.FieldValues[5] * l.DerivativeValues[2][1]) / g.Parameters[0])) / 2. + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[5][1]) / g.Parameters[0]); });
    descriptor.SetContinuousEquation(5, 1, [](const auto& l, const auto& g) {return l.DerivativeValues[5][1]; });
    descriptor.SetContinuousEquation(5, 2, [](const auto& l, const auto& g) {return l.FieldValues[5]; });
    descriptor.SetContinuousEquation(5, 3, [](const auto& l, const auto& g) {return l.FieldValues[5]; });
    descriptor.SetContinuousEquation(5, 4, [](const auto& l, const auto& g) {return l.DerivativeValues[5][0]; });
    descriptor.SetContinuousEquation(6, 0, [](const auto& l, const auto& g) {return (cos(l.Point[1]) * l.FieldValues[4]) / 2. + pow(E, l.FieldValues[1]) * (-(g.Parameters[5] * l.FieldValues[6] * l.VIEValues[0] * sin(l.Point[1])) - (l.FieldValues[7] * sin(l.Point[1]) * (g.Parameters[2] * l.VIEValues[0] - g.Parameters[4] * l.FieldValues[3])) / pow(E, l.FieldValues[0]) + (g.Parameters[4] * l.FieldValues[4]) / pow(E, l.FieldValues[2])) + pow(E, l.FieldValues[1]) * g.Parameters[3] * l.VIEValues[0] * sin(l.Point[1]) * ((l.FieldValues[7] * (l.FieldValues[9] + l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3])) / pow(E, l.FieldValues[0]) + (l.FieldValues[8] * l.FieldValues[4]) / pow(E, l.FieldValues[2])) + sin(l.Point[1]) * (l.FieldValues[6] + (l.FieldValues[4] * (l.DerivativeValues[0][0] + l.DerivativeValues[1][3] + l.DerivativeValues[2][0])) / 2. + l.DerivativeValues[4][0] + (l.FieldValues[6] * l.VIEValues[0] * ((pow(1 - l.Point[0], 2) * l.DerivativeValues[0][2]) / g.Parameters[0] + (pow(1 - l.Point[0], 2) * l.DerivativeValues[1][1]) / g.Parameters[0] + (pow(1 - l.Point[0], 2) * l.DerivativeValues[2][1]) / g.Parameters[0])) / 2. + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[6][0]) / g.Parameters[0]) + (pow(E, -l.FieldValues[0] + l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * (l.FieldValues[7] * l.DerivativeValues[3][0] + l.FieldValues[5] * (l.FieldValues[3] - (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) / g.Parameters[0]))) / 4.; });
    descriptor.SetContinuousEquation(6, 1, [](const auto& l, const auto& g) {return l.DerivativeValues[6][0]; });
    descriptor.SetContinuousEquation(6, 2, [](const auto& l, const auto& g) {return l.FieldValues[6]; });
    descriptor.SetContinuousEquation(6, 3, [](const auto& l, const auto& g) {return l.DerivativeValues[6][1]; });
    descriptor.SetContinuousEquation(6, 4, [](const auto& l, const auto& g) {return l.FieldValues[6]; });
    descriptor.SetContinuousEquation(7, 0, [](const auto& l, const auto& g) {return (cos(l.Point[1]) * l.FieldValues[5]) / 2. + pow(E, l.FieldValues[1]) * (g.Parameters[5] * l.FieldValues[7] * l.VIEValues[0] * sin(l.Point[1]) + (l.FieldValues[6] * sin(l.Point[1]) * (g.Parameters[2] * l.VIEValues[0] - g.Parameters[4] * l.FieldValues[3])) / pow(E, l.FieldValues[0]) + (g.Parameters[4] * l.FieldValues[5]) / pow(E, l.FieldValues[2])) - pow(E, l.FieldValues[1]) * g.Parameters[3] * l.VIEValues[0] * sin(l.Point[1]) * ((l.FieldValues[6] * (l.FieldValues[9] + l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3])) / pow(E, l.FieldValues[0]) - (l.FieldValues[8] * l.FieldValues[5]) / pow(E, l.FieldValues[2])) + sin(l.Point[1]) * (l.FieldValues[7] + (l.FieldValues[5] * (l.DerivativeValues[0][0] + l.DerivativeValues[1][3] + l.DerivativeValues[2][0])) / 2. + l.DerivativeValues[5][0] + (l.FieldValues[7] * l.VIEValues[0] * ((pow(1 - l.Point[0], 2) * l.DerivativeValues[0][2]) / g.Parameters[0] + (pow(1 - l.Point[0], 2) * l.DerivativeValues[1][1]) / g.Parameters[0] + (pow(1 - l.Point[0], 2) * l.DerivativeValues[2][1]) / g.Parameters[0])) / 2. + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[7][0]) / g.Parameters[0]) - (pow(E, -l.FieldValues[0] + l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * (l.FieldValues[6] * l.DerivativeValues[3][0] + l.FieldValues[4] * (l.FieldValues[3] - (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) / g.Parameters[0]))) / 4.; });
    descriptor.SetContinuousEquation(7, 1, [](const auto& l, const auto& g) {return l.DerivativeValues[7][0]; });
    descriptor.SetContinuousEquation(7, 2, [](const auto& l, const auto& g) {return l.FieldValues[7]; });
    descriptor.SetContinuousEquation(7, 3, [](const auto& l, const auto& g) {return l.DerivativeValues[7][1]; });
    descriptor.SetContinuousEquation(7, 4, [](const auto& l, const auto& g) {return l.FieldValues[7]; });
    descriptor.SetContinuousEquation(8, 0, [](const auto& l, const auto& g) {return -4 * pow(E, 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * (l.FieldValues[7] * l.FieldValues[4] - l.FieldValues[6] * l.FieldValues[5]) + l.FieldValues[8] * (-1 + cos(l.Point[1]) * sin(l.Point[1]) * (l.DerivativeValues[0][0] - l.DerivativeValues[2][0])) + pow(sin(l.Point[1]), 2) * l.DerivativeValues[8][2] + sin(l.Point[1]) * (l.DerivativeValues[8][0] * (cos(l.Point[1]) + sin(l.Point[1]) * (l.DerivativeValues[0][0] - l.DerivativeValues[2][0])) + (2 * pow(1 - l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.DerivativeValues[8][1]) / g.Parameters[0]) + l.VIEValues[0] * pow(sin(l.Point[1]), 2) * (l.FieldValues[8] + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[8][1]) / g.Parameters[0]) * ((pow(1 - l.Point[0], 2) * l.DerivativeValues[0][2]) / g.Parameters[0] - (pow(1 - l.Point[0], 2) * l.DerivativeValues[2][1]) / g.Parameters[0]) + pow(E, -2 * l.FieldValues[0] + 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 3) * (l.FieldValues[8] * sin(l.Point[1]) * pow(l.FieldValues[3], 2) - l.FieldValues[8] * cos(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[3][0] - sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] * l.DerivativeValues[3][0] - l.DerivativeValues[9][0] * l.DerivativeValues[3][0] + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * pow(l.FieldValues[3], 2) * l.DerivativeValues[8][1]) / g.Parameters[0] + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.FieldValues[3] * l.DerivativeValues[9][1]) / g.Parameters[0] - (pow(1 - l.Point[0], 2) * l.VIEValues[0] * (sin(l.Point[1]) * l.FieldValues[3] * (l.FieldValues[8] + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[8][1]) / g.Parameters[0]) + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[9][1]) / g.Parameters[0]) * l.DerivativeValues[3][1]) / g.Parameters[0]) + (pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * (-2 * pow(1 - l.Point[0], 3) * l.DerivativeValues[8][1] + pow(1 - l.Point[0], 4) * l.DerivativeValues[8][3])) / pow(g.Parameters[0], 2); });
    descriptor.SetContinuousEquation(8, 1, [](const auto& l, const auto& g) {return l.FieldValues[8]; });
    descriptor.SetContinuousEquation(8, 2, [](const auto& l, const auto& g) {return l.FieldValues[8]; });
    descriptor.SetContinuousEquation(8, 3, [](const auto& l, const auto& g) {return l.FieldValues[8]; });
    descriptor.SetContinuousEquation(8, 4, [](const auto& l, const auto& g) {return l.FieldValues[8]; });
    descriptor.SetContinuousEquation(9, 0, [](const auto& l, const auto& g) {return 4 * pow(E, 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 3) * l.FieldValues[3] * (l.FieldValues[7] * l.FieldValues[4] - l.FieldValues[6] * l.FieldValues[5]) + 2 * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * (pow(l.FieldValues[6], 2) + pow(l.FieldValues[7], 2) + pow(l.FieldValues[4], 2) + pow(l.FieldValues[5], 2)) + sin(l.Point[1]) * ((l.FieldValues[8] * (sin(2 * l.Point[1]) * l.DerivativeValues[3][0] + l.FieldValues[3] * (3 + cos(2 * l.Point[1]) + 2 * sin(2 * l.Point[1]) * l.DerivativeValues[2][0] - 4 * sin(l.Point[1]) * (cos(l.Point[1]) * l.DerivativeValues[0][0] + l.VIEValues[0] * sin(l.Point[1]) * ((pow(1 - l.Point[0], 2) * l.DerivativeValues[0][2]) / g.Parameters[0] - (pow(1 - l.Point[0], 2) * l.DerivativeValues[2][1]) / g.Parameters[0])))) + 2 * ((cos(l.Point[1]) + sin(l.Point[1]) * (-l.DerivativeValues[0][0] + l.DerivativeValues[2][0])) * l.DerivativeValues[9][0] + sin(l.Point[1]) * l.FieldValues[3] * (2 * l.DerivativeValues[8][0] * (cos(l.Point[1]) + sin(l.Point[1]) * (-l.DerivativeValues[0][0] + l.DerivativeValues[2][0])) + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.DerivativeValues[8][1] * (1 - (2 * pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[0][2]) / g.Parameters[0] + (2 * pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[2][1]) / g.Parameters[0])) / g.Parameters[0]) + sin(l.Point[1]) * (sin(l.Point[1]) * l.DerivativeValues[8][0] * l.DerivativeValues[3][0] + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * (2 - (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[0][2]) / g.Parameters[0] + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[2][1]) / g.Parameters[0]) * l.DerivativeValues[9][1]) / g.Parameters[0]))) / 2. + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * (l.FieldValues[8] + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[8][1]) / g.Parameters[0]) * l.DerivativeValues[3][1]) / g.Parameters[0]) + pow(E, -2 * l.FieldValues[0] + 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 4) * l.FieldValues[3] * (-(l.FieldValues[8] * sin(l.Point[1]) * pow(l.FieldValues[3], 2)) + l.FieldValues[8] * cos(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[3][0] + sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] * l.DerivativeValues[3][0] + l.DerivativeValues[9][0] * l.DerivativeValues[3][0] - (pow(1 - l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * pow(l.FieldValues[3], 2) * l.DerivativeValues[8][1]) / g.Parameters[0] - (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.FieldValues[3] * l.DerivativeValues[9][1]) / g.Parameters[0] + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * (sin(l.Point[1]) * l.FieldValues[3] * (l.FieldValues[8] + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[8][1]) / g.Parameters[0]) + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[9][1]) / g.Parameters[0]) * l.DerivativeValues[3][1]) / g.Parameters[0]) + pow(sin(l.Point[1]), 2) * (l.DerivativeValues[9][2] + (pow(l.VIEValues[0], 2) * (-2 * pow(1 - l.Point[0], 3) * l.DerivativeValues[9][1] + pow(1 - l.Point[0], 4) * l.DerivativeValues[9][3])) / pow(g.Parameters[0], 2)); });
    descriptor.SetContinuousEquation(9, 1, [](const auto& l, const auto& g) {return l.DerivativeValues[9][1]; });
    descriptor.SetContinuousEquation(9, 2, [](const auto& l, const auto& g) {return l.FieldValues[9]; });
    descriptor.SetContinuousEquation(9, 3, [](const auto& l, const auto& g) {return l.DerivativeValues[9][0]; });
    descriptor.SetContinuousEquation(9, 4, [](const auto& l, const auto& g) {return l.DerivativeValues[9][0]; });
    descriptor.SetJacobianComponent(0, 0, 0, 0, [](const auto& l, const auto& g) {return (pow(sin(l.Point[1]), 2) * (4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(l.FieldValues[8], 2) * pow(l.FieldValues[3], 2) + 2 * pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) + 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[2] * pow(l.VIEValues[0], 2) * pow(l.FieldValues[4], 2) - 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * l.FieldValues[9] * pow(l.FieldValues[4], 2) - 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[4] * l.VIEValues[0] * l.FieldValues[3] * pow(l.FieldValues[4], 2) - 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[3] * pow(l.FieldValues[4], 2) + 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[2] * pow(l.VIEValues[0], 2) * pow(l.FieldValues[5], 2) - 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * l.FieldValues[9] * pow(l.FieldValues[5], 2) - 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[4] * l.VIEValues[0] * l.FieldValues[3] * pow(l.FieldValues[5], 2) - 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[3] * pow(l.FieldValues[5], 2) + 8 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * l.FieldValues[8] * cos(l.Point[1]) * sin(l.Point[1]) * pow(l.FieldValues[3], 2) * l.DerivativeValues[8][0] + 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) * pow(l.DerivativeValues[8][0], 2) + 8 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * l.FieldValues[8] * cos(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[9][0] + 8 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] * l.DerivativeValues[9][0] + 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(l.DerivativeValues[9][0], 2) + pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * pow(l.FieldValues[4], 2) * l.DerivativeValues[3][0] + pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * pow(l.FieldValues[5], 2) * l.DerivativeValues[3][0] + 2 * pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.DerivativeValues[3][0], 2) + pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * pow(l.FieldValues[6], 2) * l.VIEValues[0] * (-4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] + 4 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) + pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * pow(l.FieldValues[7], 2) * l.VIEValues[0] * (-4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] + 4 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) + 8 * pow(g.Parameters[1], 2) * g.Parameters[0] * l.FieldValues[8] * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) * l.DerivativeValues[8][1] - 16 * pow(g.Parameters[1], 2) * g.Parameters[0] * l.Point[0] * l.FieldValues[8] * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) * l.DerivativeValues[8][1] + 8 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(l.Point[0], 2) * l.FieldValues[8] * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) * l.DerivativeValues[8][1] + 4 * pow(g.Parameters[1], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) * pow(l.DerivativeValues[8][1], 2) - 16 * pow(g.Parameters[1], 2) * l.Point[0] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) * pow(l.DerivativeValues[8][1], 2) + 24 * pow(g.Parameters[1], 2) * pow(l.Point[0], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) * pow(l.DerivativeValues[8][1], 2) - 16 * pow(g.Parameters[1], 2) * pow(l.Point[0], 3) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) * pow(l.DerivativeValues[8][1], 2) + 4 * pow(g.Parameters[1], 2) * pow(l.Point[0], 4) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) * pow(l.DerivativeValues[8][1], 2) + 8 * pow(g.Parameters[1], 2) * g.Parameters[0] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[9][1] - 16 * pow(g.Parameters[1], 2) * g.Parameters[0] * l.Point[0] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[9][1] + 8 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(l.Point[0], 2) * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[9][1] + 8 * pow(g.Parameters[1], 2) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] * l.DerivativeValues[9][1] - 32 * pow(g.Parameters[1], 2) * l.Point[0] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] * l.DerivativeValues[9][1] + 48 * pow(g.Parameters[1], 2) * pow(l.Point[0], 2) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] * l.DerivativeValues[9][1] - 32 * pow(g.Parameters[1], 2) * pow(l.Point[0], 3) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] * l.DerivativeValues[9][1] + 8 * pow(g.Parameters[1], 2) * pow(l.Point[0], 4) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] * l.DerivativeValues[9][1] + 4 * pow(g.Parameters[1], 2) * pow(l.VIEValues[0], 2) * pow(l.DerivativeValues[9][1], 2) - 16 * pow(g.Parameters[1], 2) * l.Point[0] * pow(l.VIEValues[0], 2) * pow(l.DerivativeValues[9][1], 2) + 24 * pow(g.Parameters[1], 2) * pow(l.Point[0], 2) * pow(l.VIEValues[0], 2) * pow(l.DerivativeValues[9][1], 2) - 16 * pow(g.Parameters[1], 2) * pow(l.Point[0], 3) * pow(l.VIEValues[0], 2) * pow(l.DerivativeValues[9][1], 2) + 4 * pow(g.Parameters[1], 2) * pow(l.Point[0], 4) * pow(l.VIEValues[0], 2) * pow(l.DerivativeValues[9][1], 2) - 4 * g.Parameters[0] * pow(E, 2 * l.FieldValues[2]) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.DerivativeValues[3][1] + 8 * g.Parameters[0] * pow(E, 2 * l.FieldValues[2]) * l.Point[0] * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.DerivativeValues[3][1] - 4 * g.Parameters[0] * pow(E, 2 * l.FieldValues[2]) * pow(l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.DerivativeValues[3][1] + 2 * pow(E, 2 * l.FieldValues[2]) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.DerivativeValues[3][1], 2) - 8 * pow(E, 2 * l.FieldValues[2]) * l.Point[0] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.DerivativeValues[3][1], 2) + 12 * pow(E, 2 * l.FieldValues[2]) * pow(l.Point[0], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.DerivativeValues[3][1], 2) - 8 * pow(E, 2 * l.FieldValues[2]) * pow(l.Point[0], 3) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.DerivativeValues[3][1], 2) + 2 * pow(E, 2 * l.FieldValues[2]) * pow(l.Point[0], 4) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.DerivativeValues[3][1], 2) - 2 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[6] * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[4] * (g.Parameters[0] * l.FieldValues[3] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) - 2 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[7] * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[5] * (g.Parameters[0] * l.FieldValues[3] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]))) / (2. * pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[0])); });
    descriptor.SetJacobianComponent(0, 1, 0, 0, [](const auto& l, const auto& g) {return (pow(g.Parameters[1], 2) * pow(E, -l.FieldValues[0] + l.FieldValues[1] - l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * (g.Parameters[0] * pow(E, l.FieldValues[2]) * pow(l.FieldValues[6], 2) * sin(l.Point[1]) * (8 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] - 8 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) + g.Parameters[0] * pow(E, l.FieldValues[2]) * pow(l.FieldValues[7], 2) * sin(l.Point[1]) * (8 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] - 8 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) + 2 * l.FieldValues[6] * (g.Parameters[0] * pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.FieldValues[4] + 8 * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[5] + 2 * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[5][0] + pow(E, l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * (2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[7][0] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[4] * l.DerivativeValues[3][1])) - 2 * l.FieldValues[7] * (8 * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[4] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (g.Parameters[0] * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[3] * l.FieldValues[5] - 2 * g.Parameters[0] * pow(E, l.FieldValues[0]) * l.DerivativeValues[4][0] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[6][0] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[5] * l.DerivativeValues[3][1]))) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (g.Parameters[0] * (8 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] * (pow(l.FieldValues[4], 2) + pow(l.FieldValues[5], 2)) - 4 * pow(E, l.FieldValues[0]) * l.FieldValues[5] * l.DerivativeValues[6][1] + 4 * pow(E, l.FieldValues[0]) * l.FieldValues[4] * l.DerivativeValues[7][1] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * pow(l.FieldValues[4], 2) * l.DerivativeValues[3][0] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * pow(l.FieldValues[5], 2) * l.DerivativeValues[3][0]) + l.VIEValues[0] * (-8 * g.Parameters[0] * pow(E, l.FieldValues[1]) * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) * pow(l.FieldValues[4], 2) + 4 * l.FieldValues[5] * (-2 * g.Parameters[0] * pow(E, l.FieldValues[1]) * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) * l.FieldValues[5] + pow(E, l.FieldValues[0]) * pow(-1 + l.Point[0], 2) * l.DerivativeValues[4][1]) - 4 * pow(E, l.FieldValues[0]) * pow(-1 + l.Point[0], 2) * l.FieldValues[4] * l.DerivativeValues[5][1])))) / (2. * g.Parameters[0]); });
    descriptor.SetJacobianComponent(0, 2, 0, 0, [](const auto& l, const auto& g) {return (4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[0]) * pow(l.FieldValues[8], 2) + 8 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, 2 * l.FieldValues[0]) * l.FieldValues[8] * sin(l.Point[1]) * (g.Parameters[0] * pow(E, 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[3] * l.FieldValues[7] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[4] - g.Parameters[0] * pow(E, 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[3] * l.FieldValues[6] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[5] + g.Parameters[0] * cos(l.Point[1]) * l.DerivativeValues[8][0] + l.VIEValues[0] * sin(l.Point[1]) * l.DerivativeValues[8][1] - 2 * l.Point[0] * l.VIEValues[0] * sin(l.Point[1]) * l.DerivativeValues[8][1] + pow(l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.DerivativeValues[8][1]) + sin(l.Point[1]) * (-2 * pow(g.Parameters[0], 2) * pow(E, 4 * l.FieldValues[2]) * pow(sin(l.Point[1]), 3) * pow(l.FieldValues[3], 2) - 8 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[0] + 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[4] * l.FieldValues[6] * l.VIEValues[0] * l.FieldValues[5] + 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[0]) * sin(l.Point[1]) * pow(l.DerivativeValues[8][0], 2) + pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + 3 * l.FieldValues[2]) * pow(l.FieldValues[6], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.DerivativeValues[3][0] + pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + 3 * l.FieldValues[2]) * pow(l.FieldValues[7], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.DerivativeValues[3][0] - pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + 3 * l.FieldValues[2]) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[4], 2) * l.DerivativeValues[3][0] - pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + 3 * l.FieldValues[2]) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[5], 2) * l.DerivativeValues[3][0] - 2 * pow(g.Parameters[0], 2) * pow(E, 4 * l.FieldValues[2]) * pow(sin(l.Point[1]), 3) * pow(l.DerivativeValues[3][0], 2) + 4 * pow(g.Parameters[1], 2) * pow(E, 2 * l.FieldValues[0]) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * pow(l.DerivativeValues[8][1], 2) - 16 * pow(g.Parameters[1], 2) * pow(E, 2 * l.FieldValues[0]) * l.Point[0] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * pow(l.DerivativeValues[8][1], 2) + 24 * pow(g.Parameters[1], 2) * pow(E, 2 * l.FieldValues[0]) * pow(l.Point[0], 2) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * pow(l.DerivativeValues[8][1], 2) - 16 * pow(g.Parameters[1], 2) * pow(E, 2 * l.FieldValues[0]) * pow(l.Point[0], 3) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * pow(l.DerivativeValues[8][1], 2) + 4 * pow(g.Parameters[1], 2) * pow(E, 2 * l.FieldValues[0]) * pow(l.Point[0], 4) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * pow(l.DerivativeValues[8][1], 2) - 2 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1] + 3 * l.FieldValues[2]) * l.FieldValues[6] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[4] * l.DerivativeValues[3][1] + 4 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1] + 3 * l.FieldValues[2]) * l.Point[0] * l.FieldValues[6] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[4] * l.DerivativeValues[3][1] - 2 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1] + 3 * l.FieldValues[2]) * pow(l.Point[0], 2) * l.FieldValues[6] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[4] * l.DerivativeValues[3][1] - 2 * pow(E, 4 * l.FieldValues[2]) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 3) * pow(l.DerivativeValues[3][1], 2) + 8 * pow(E, 4 * l.FieldValues[2]) * l.Point[0] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 3) * pow(l.DerivativeValues[3][1], 2) - 12 * pow(E, 4 * l.FieldValues[2]) * pow(l.Point[0], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 3) * pow(l.DerivativeValues[3][1], 2) + 8 * pow(E, 4 * l.FieldValues[2]) * pow(l.Point[0], 3) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 3) * pow(l.DerivativeValues[3][1], 2) - 2 * pow(E, 4 * l.FieldValues[2]) * pow(l.Point[0], 4) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 3) * pow(l.DerivativeValues[3][1], 2) + 2 * g.Parameters[0] * pow(E, 3 * l.FieldValues[2]) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * (pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.FieldValues[6] * l.FieldValues[4] + pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.FieldValues[7] * l.FieldValues[5] + 2 * pow(E, l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * sin(l.Point[1]) * l.DerivativeValues[3][1]) - 2 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[7] * l.VIEValues[0] * (-4 * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[4] + pow(E, 2 * l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[5] * l.DerivativeValues[3][1]))) / (2. * pow(g.Parameters[0], 2) * pow(E, 2 * (l.FieldValues[0] + l.FieldValues[2]))); });
    descriptor.SetJacobianComponent(0, 3, 0, 0, [](const auto& l, const auto& g) {return (pow(sin(l.Point[1]), 2) * (2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * pow(l.FieldValues[6], 2) * l.VIEValues[0] * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) + 2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * pow(l.FieldValues[7], 2) * l.VIEValues[0] * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) + pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[6] * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[4] + pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[7] * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[5] - (2 * pow(g.Parameters[1], 2) * (pow(g.Parameters[0], 2) * pow(l.FieldValues[8], 2) * l.FieldValues[3] - pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[4] * l.VIEValues[0] * (pow(l.FieldValues[4], 2) + pow(l.FieldValues[5], 2)) + pow(g.Parameters[0], 2) * sin(l.Point[1]) * l.DerivativeValues[8][0] * (sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] + l.DerivativeValues[9][0]) + pow(-1 + l.Point[0], 4) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.DerivativeValues[8][1] * (sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] + l.DerivativeValues[9][1]) - g.Parameters[0] * l.FieldValues[8] * (g.Parameters[0] * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * (pow(l.FieldValues[4], 2) + pow(l.FieldValues[5], 2)) - g.Parameters[0] * cos(l.Point[1]) * (2 * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] + l.DerivativeValues[9][0]) - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * (2 * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] + l.DerivativeValues[9][1])))) / pow(g.Parameters[0], 2) - pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * (l.FieldValues[3] - (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) / g.Parameters[0]))) / pow(E, 2 * l.FieldValues[0]); });
    descriptor.SetJacobianComponent(0, 4, 0, 0, [](const auto& l, const auto& g) {return (pow(g.Parameters[1], 2) * pow(E, -l.FieldValues[0] + l.FieldValues[1] - l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * (-4 * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.FieldValues[7] * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (g.Parameters[0] * (4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] * l.FieldValues[4] + 2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[7][1] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[4] * l.DerivativeValues[3][0]) + pow(E, l.FieldValues[2]) * l.FieldValues[6] * sin(l.Point[1]) * (g.Parameters[0] * l.FieldValues[3] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) - 2 * l.VIEValues[0] * (2 * g.Parameters[0] * pow(E, l.FieldValues[1]) * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) * l.FieldValues[4] + pow(E, l.FieldValues[0]) * pow(-1 + l.Point[0], 2) * l.DerivativeValues[5][1])))) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(0, 5, 0, 0, [](const auto& l, const auto& g) {return (pow(g.Parameters[1], 2) * pow(E, -l.FieldValues[0] + l.FieldValues[1] - l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * (4 * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.FieldValues[6] * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (g.Parameters[0] * (4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] * l.FieldValues[5] - 2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[6][1] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[5] * l.DerivativeValues[3][0]) + pow(E, l.FieldValues[2]) * l.FieldValues[7] * sin(l.Point[1]) * (g.Parameters[0] * l.FieldValues[3] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) + l.VIEValues[0] * (-4 * g.Parameters[0] * pow(E, l.FieldValues[1]) * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) * l.FieldValues[5] + 2 * pow(E, l.FieldValues[0]) * pow(-1 + l.Point[0], 2) * l.DerivativeValues[4][1])))) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(0, 6, 0, 0, [](const auto& l, const auto& g) {return -(pow(g.Parameters[1], 2) * pow(E, -l.FieldValues[0] + l.FieldValues[1] - l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * (-4 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) * (pow(E, l.FieldValues[2]) * l.FieldValues[6] * sin(l.Point[1]) * l.FieldValues[3] + pow(E, l.FieldValues[0]) * l.FieldValues[5]) - pow(E, l.FieldValues[2]) * l.FieldValues[6] * sin(l.Point[1]) * (-4 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9]) + 4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) - (g.Parameters[0] * pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.FieldValues[4] + 4 * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[5] + 2 * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[5][0] + pow(E, l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * (2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[7][0] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[4] * l.DerivativeValues[3][1])) / g.Parameters[0])); });
    descriptor.SetJacobianComponent(0, 7, 0, 0, [](const auto& l, const auto& g) {return (pow(g.Parameters[1], 2) * pow(E, -l.FieldValues[0] + l.FieldValues[1] - l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * (-4 * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[4] + g.Parameters[0] * pow(E, l.FieldValues[2]) * l.FieldValues[7] * sin(l.Point[1]) * (4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] - 4 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (g.Parameters[0] * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[3] * l.FieldValues[5] - 2 * g.Parameters[0] * pow(E, l.FieldValues[0]) * l.DerivativeValues[4][0] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[6][0] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[5] * l.DerivativeValues[3][1])))) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(0, 8, 0, 0, [](const auto& l, const auto& g) {return -0.5 * (pow(g.Parameters[1], 2) * (4 * l.FieldValues[8] * (pow(E, 2 * l.FieldValues[0]) + pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2)) + 4 * sin(l.Point[1]) * (-(pow(E, l.FieldValues[0] + 2 * (l.FieldValues[1] + l.FieldValues[2])) * g.Parameters[3] * pow(l.FieldValues[6], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[3]) - pow(E, l.FieldValues[0] + 2 * (l.FieldValues[1] + l.FieldValues[2])) * g.Parameters[3] * pow(l.FieldValues[7], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] + 2 * pow(E, 2 * l.FieldValues[0] + 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[3] * l.FieldValues[7] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[4] - pow(E, l.FieldValues[0] + 2 * (l.FieldValues[1] + l.FieldValues[2])) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * pow(l.FieldValues[4], 2) - 2 * pow(E, 2 * l.FieldValues[0] + 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[3] * l.FieldValues[6] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[5] - pow(E, l.FieldValues[0] + 2 * (l.FieldValues[1] + l.FieldValues[2])) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * pow(l.FieldValues[5], 2) + pow(E, 2 * l.FieldValues[0]) * cos(l.Point[1]) * l.DerivativeValues[8][0] + pow(E, 2 * l.FieldValues[2]) * cos(l.Point[1]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) * l.DerivativeValues[8][0] + pow(E, 2 * l.FieldValues[2]) * cos(l.Point[1]) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[9][0] + (pow(E, 2 * l.FieldValues[0]) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.DerivativeValues[8][1]) / g.Parameters[0] + (pow(E, 2 * l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 3) * pow(l.FieldValues[3], 2) * l.DerivativeValues[8][1]) / g.Parameters[0] + (pow(E, 2 * l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.DerivativeValues[9][1]) / g.Parameters[0]))) / pow(E, 2 * (l.FieldValues[0] + l.FieldValues[2])); });
    descriptor.SetJacobianComponent(0, 9, 0, 0, [](const auto& l, const auto& g) {return 2 * pow(g.Parameters[1], 2) * pow(E, -l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * (pow(l.FieldValues[6], 2) + pow(l.FieldValues[7], 2) + pow(l.FieldValues[4], 2) + pow(l.FieldValues[5], 2)); });
    descriptor.SetJacobianComponent(0, 0, 1, 0, [](const auto& l, const auto& g) {return sin(l.Point[1]) * (cos(l.Point[1]) + sin(l.Point[1]) * (2 * l.DerivativeValues[0][0] + l.DerivativeValues[2][0])); });
    descriptor.SetJacobianComponent(0, 0, 2, 0, [](const auto& l, const auto& g) {return pow(sin(l.Point[1]), 2); });
    descriptor.SetJacobianComponent(0, 0, 3, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * (2 * g.Parameters[0] + (-1 + l.Point[0]) * l.VIEValues[0] * (2 + 2 * (-1 + l.Point[0]) * l.DerivativeValues[0][2] + (-1 + l.Point[0]) * l.DerivativeValues[2][1]))) / pow(g.Parameters[0], 2); });
    descriptor.SetJacobianComponent(0, 0, 4, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 4) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2)) / pow(g.Parameters[0], 2); });
    descriptor.SetJacobianComponent(0, 2, 1, 0, [](const auto& l, const auto& g) {return pow(sin(l.Point[1]), 2) * l.DerivativeValues[0][0]; });
    descriptor.SetJacobianComponent(0, 2, 2, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 4) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.DerivativeValues[0][2]) / pow(g.Parameters[0], 2); });
    descriptor.SetJacobianComponent(0, 3, 1, 0, [](const auto& l, const auto& g) {return -0.5 * (pow(E, -2 * l.FieldValues[0] + l.FieldValues[2]) * pow(sin(l.Point[1]), 3) * (-(pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * pow(l.FieldValues[6], 2) * l.VIEValues[0]) - pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * pow(l.FieldValues[7], 2) * l.VIEValues[0] + pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.VIEValues[0] * pow(l.FieldValues[4], 2) + pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.VIEValues[0] * pow(l.FieldValues[5], 2) + 2 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0])); });
    descriptor.SetJacobianComponent(0, 3, 2, 0, [](const auto& l, const auto& g) {return -((pow(E, -2 * l.FieldValues[0] + l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 3) * (-(g.Parameters[0] * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[3]) + l.VIEValues[0] * (pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.FieldValues[6] * l.FieldValues[4] + pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.FieldValues[7] * l.FieldValues[5] + pow(E, l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * sin(l.Point[1]) * l.DerivativeValues[3][1]))) / pow(g.Parameters[0], 2)); });
    descriptor.SetJacobianComponent(0, 4, 1, 0, [](const auto& l, const auto& g) {return -2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * l.FieldValues[7] * l.VIEValues[0] * pow(sin(l.Point[1]), 2); });
    descriptor.SetJacobianComponent(0, 4, 2, 0, [](const auto& l, const auto& g) {return (2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * pow(-1 + l.Point[0], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[5]) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(0, 5, 1, 0, [](const auto& l, const auto& g) {return 2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * l.FieldValues[6] * l.VIEValues[0] * pow(sin(l.Point[1]), 2); });
    descriptor.SetJacobianComponent(0, 5, 2, 0, [](const auto& l, const auto& g) {return (-2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * pow(-1 + l.Point[0], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[4]) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(0, 6, 1, 0, [](const auto& l, const auto& g) {return (-2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * pow(-1 + l.Point[0], 2) * l.FieldValues[7] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2)) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(0, 6, 2, 0, [](const auto& l, const auto& g) {return -2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[5]; });
    descriptor.SetJacobianComponent(0, 7, 1, 0, [](const auto& l, const auto& g) {return (2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * pow(-1 + l.Point[0], 2) * l.FieldValues[6] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2)) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(0, 7, 2, 0, [](const auto& l, const auto& g) {return 2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[4]; });
    descriptor.SetJacobianComponent(0, 8, 1, 0, [](const auto& l, const auto& g) {return (-2 * pow(g.Parameters[1], 2) * sin(l.Point[1]) * (l.FieldValues[8] * cos(l.Point[1]) * (pow(E, 2 * l.FieldValues[0]) + pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2)) + sin(l.Point[1]) * ((pow(E, 2 * l.FieldValues[0]) + pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2)) * l.DerivativeValues[8][0] + pow(E, 2 * l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[9][0]))) / pow(E, 2 * (l.FieldValues[0] + l.FieldValues[2])); });
    descriptor.SetJacobianComponent(0, 8, 2, 0, [](const auto& l, const auto& g) {return (-2 * pow(g.Parameters[1], 2) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * (g.Parameters[0] * l.FieldValues[8] * (pow(E, 2 * l.FieldValues[0]) + pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2)) + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * ((pow(E, 2 * l.FieldValues[0]) + pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2)) * l.DerivativeValues[8][1] + pow(E, 2 * l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[9][1]))) / (pow(g.Parameters[0], 2) * pow(E, 2 * (l.FieldValues[0] + l.FieldValues[2]))); });
    descriptor.SetJacobianComponent(0, 9, 1, 0, [](const auto& l, const auto& g) {return (-2 * pow(g.Parameters[1], 2) * pow(sin(l.Point[1]), 2) * (l.FieldValues[8] * cos(l.Point[1]) * l.FieldValues[3] + sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] + l.DerivativeValues[9][0])) / pow(E, 2 * l.FieldValues[0]); });
    descriptor.SetJacobianComponent(0, 9, 2, 0, [](const auto& l, const auto& g) {return (-2 * pow(g.Parameters[1], 2) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * (g.Parameters[0] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] + l.DerivativeValues[9][1]))) / (pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[0])); });
    descriptor.SetJacobianComponent(0, 0, 3, 1, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(0, 0, 0, 2, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(0, 0, 1, 3, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(0, 0, 1, 4, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(1, 0, 0, 0, [](const auto& l, const auto& g) {return (pow(sin(l.Point[1]), 2) * (pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) - 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[2] * pow(l.VIEValues[0], 2) * pow(l.FieldValues[4], 2) + 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * l.FieldValues[9] * pow(l.FieldValues[4], 2) + 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[4] * l.VIEValues[0] * l.FieldValues[3] * pow(l.FieldValues[4], 2) + 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[3] * pow(l.FieldValues[4], 2) - 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[2] * pow(l.VIEValues[0], 2) * pow(l.FieldValues[5], 2) + 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * l.FieldValues[9] * pow(l.FieldValues[5], 2) + 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[4] * l.VIEValues[0] * l.FieldValues[3] * pow(l.FieldValues[5], 2) + 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[3] * pow(l.FieldValues[5], 2) + pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * pow(l.FieldValues[4], 2) * l.DerivativeValues[3][0] + pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * pow(l.FieldValues[5], 2) * l.DerivativeValues[3][0] + pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.DerivativeValues[3][0], 2) - pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * pow(l.FieldValues[6], 2) * l.VIEValues[0] * (-4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] + 4 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) - pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * pow(l.FieldValues[7], 2) * l.VIEValues[0] * (-4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] + 4 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) - 2 * g.Parameters[0] * pow(E, 2 * l.FieldValues[2]) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.DerivativeValues[3][1] + 4 * g.Parameters[0] * pow(E, 2 * l.FieldValues[2]) * l.Point[0] * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.DerivativeValues[3][1] - 2 * g.Parameters[0] * pow(E, 2 * l.FieldValues[2]) * pow(l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.DerivativeValues[3][1] + pow(E, 2 * l.FieldValues[2]) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.DerivativeValues[3][1], 2) - 4 * pow(E, 2 * l.FieldValues[2]) * l.Point[0] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.DerivativeValues[3][1], 2) + 6 * pow(E, 2 * l.FieldValues[2]) * pow(l.Point[0], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.DerivativeValues[3][1], 2) - 4 * pow(E, 2 * l.FieldValues[2]) * pow(l.Point[0], 3) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.DerivativeValues[3][1], 2) + pow(E, 2 * l.FieldValues[2]) * pow(l.Point[0], 4) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.DerivativeValues[3][1], 2) - 2 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[6] * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[4] * (g.Parameters[0] * l.FieldValues[3] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) - 2 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[7] * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[5] * (g.Parameters[0] * l.FieldValues[3] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]))) / (2. * pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[0])); });
    descriptor.SetJacobianComponent(1, 1, 0, 0, [](const auto& l, const auto& g) {return -0.5 * (pow(g.Parameters[1], 2) * pow(E, -l.FieldValues[0] + l.FieldValues[1] - l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * (-(g.Parameters[0] * pow(E, l.FieldValues[2]) * pow(l.FieldValues[6], 2) * sin(l.Point[1]) * (-8 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] + 8 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0])) - g.Parameters[0] * pow(E, l.FieldValues[2]) * pow(l.FieldValues[7], 2) * sin(l.Point[1]) * (-8 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] + 8 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) - 2 * l.FieldValues[6] * (g.Parameters[0] * pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.FieldValues[4] + 8 * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[5] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (2 * g.Parameters[0] * pow(E, l.FieldValues[0]) * l.DerivativeValues[5][0] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[7][0] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[4] * l.DerivativeValues[3][1]))) + 2 * l.FieldValues[7] * (8 * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[4] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (g.Parameters[0] * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[3] * l.FieldValues[5] + 2 * g.Parameters[0] * pow(E, l.FieldValues[0]) * l.DerivativeValues[4][0] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[6][0] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[5] * l.DerivativeValues[3][1]))) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (g.Parameters[0] * (8 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] * (pow(l.FieldValues[4], 2) + pow(l.FieldValues[5], 2)) - 4 * pow(E, l.FieldValues[0]) * l.FieldValues[5] * l.DerivativeValues[6][1] + 4 * pow(E, l.FieldValues[0]) * l.FieldValues[4] * l.DerivativeValues[7][1] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * pow(l.FieldValues[4], 2) * l.DerivativeValues[3][0] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * pow(l.FieldValues[5], 2) * l.DerivativeValues[3][0]) + l.VIEValues[0] * (-8 * g.Parameters[0] * pow(E, l.FieldValues[1]) * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) * pow(l.FieldValues[4], 2) + 4 * l.FieldValues[5] * (-2 * g.Parameters[0] * pow(E, l.FieldValues[1]) * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) * l.FieldValues[5] + pow(E, l.FieldValues[0]) * pow(-1 + l.Point[0], 2) * l.DerivativeValues[4][1]) - 4 * pow(E, l.FieldValues[0]) * pow(-1 + l.Point[0], 2) * l.FieldValues[4] * l.DerivativeValues[5][1])))) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(1, 2, 0, 0, [](const auto& l, const auto& g) {return -0.5 * (pow(E, -2 * l.FieldValues[0] - l.FieldValues[2]) * sin(l.Point[1]) * (pow(g.Parameters[0], 2) * pow(E, 3 * l.FieldValues[2]) * pow(sin(l.Point[1]), 3) * pow(l.FieldValues[3], 2) + 8 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, 2 * (l.FieldValues[0] + l.FieldValues[1])) * g.Parameters[4] * l.FieldValues[6] * l.VIEValues[0] * l.FieldValues[5] + 8 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, 2 * (l.FieldValues[0] + l.FieldValues[1])) * g.Parameters[3] * l.FieldValues[8] * l.FieldValues[6] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[5] - pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + 2 * l.FieldValues[2]) * pow(l.FieldValues[6], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.DerivativeValues[3][0] - pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + 2 * l.FieldValues[2]) * pow(l.FieldValues[7], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.DerivativeValues[3][0] + pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + 2 * l.FieldValues[2]) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[4], 2) * l.DerivativeValues[3][0] + pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + 2 * l.FieldValues[2]) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[5], 2) * l.DerivativeValues[3][0] + pow(g.Parameters[0], 2) * pow(E, 3 * l.FieldValues[2]) * pow(sin(l.Point[1]), 3) * pow(l.DerivativeValues[3][0], 2) + 2 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1] + 2 * l.FieldValues[2]) * l.FieldValues[6] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[4] * l.DerivativeValues[3][1] - 4 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1] + 2 * l.FieldValues[2]) * l.Point[0] * l.FieldValues[6] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[4] * l.DerivativeValues[3][1] + 2 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1] + 2 * l.FieldValues[2]) * pow(l.Point[0], 2) * l.FieldValues[6] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[4] * l.DerivativeValues[3][1] + pow(E, 3 * l.FieldValues[2]) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 3) * pow(l.DerivativeValues[3][1], 2) - 4 * pow(E, 3 * l.FieldValues[2]) * l.Point[0] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 3) * pow(l.DerivativeValues[3][1], 2) + 6 * pow(E, 3 * l.FieldValues[2]) * pow(l.Point[0], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 3) * pow(l.DerivativeValues[3][1], 2) - 4 * pow(E, 3 * l.FieldValues[2]) * pow(l.Point[0], 3) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 3) * pow(l.DerivativeValues[3][1], 2) + pow(E, 3 * l.FieldValues[2]) * pow(l.Point[0], 4) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 3) * pow(l.DerivativeValues[3][1], 2) - 2 * g.Parameters[0] * pow(E, 2 * l.FieldValues[2]) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * (pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.FieldValues[6] * l.FieldValues[4] + pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.FieldValues[7] * l.FieldValues[5] + pow(E, l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * sin(l.Point[1]) * l.DerivativeValues[3][1]) - 2 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.FieldValues[7] * l.VIEValues[0] * (4 * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[4] - pow(E, 2 * l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[5] * l.DerivativeValues[3][1]))) / pow(g.Parameters[0], 2); });
    descriptor.SetJacobianComponent(1, 3, 0, 0, [](const auto& l, const auto& g) {return (pow(sin(l.Point[1]), 2) * (-(pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.VIEValues[0] * (4 * pow(E, l.FieldValues[1]) * pow(l.FieldValues[6], 2) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) + 4 * pow(E, l.FieldValues[1]) * pow(l.FieldValues[7], 2) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) - 2 * pow(E, l.FieldValues[2]) * l.FieldValues[6] * sin(l.Point[1]) * l.FieldValues[4] - 2 * pow(E, l.FieldValues[2]) * l.FieldValues[7] * sin(l.Point[1]) * l.FieldValues[5] + 4 * pow(E, l.FieldValues[1]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * (pow(l.FieldValues[4], 2) + pow(l.FieldValues[5], 2)))) - pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * (l.FieldValues[3] - (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) / g.Parameters[0]))) / (2. * pow(E, 2 * l.FieldValues[0])); });
    descriptor.SetJacobianComponent(1, 4, 0, 0, [](const auto& l, const auto& g) {return pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * l.VIEValues[0] * sin(l.Point[1]) * (-4 * pow(E, l.FieldValues[1] - l.FieldValues[2]) * l.FieldValues[7] * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) + (sin(l.Point[1]) * (-(g.Parameters[0] * (4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] * l.FieldValues[4] + 2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[7][1] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[4] * l.DerivativeValues[3][0])) + pow(E, l.FieldValues[2]) * l.FieldValues[6] * sin(l.Point[1]) * (g.Parameters[0] * l.FieldValues[3] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) + 2 * l.VIEValues[0] * (2 * g.Parameters[0] * pow(E, l.FieldValues[1]) * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) * l.FieldValues[4] + pow(E, l.FieldValues[0]) * pow(-1 + l.Point[0], 2) * l.DerivativeValues[5][1]))) / (g.Parameters[0] * pow(E, l.FieldValues[0]))); });
    descriptor.SetJacobianComponent(1, 5, 0, 0, [](const auto& l, const auto& g) {return pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * l.VIEValues[0] * sin(l.Point[1]) * (4 * pow(E, l.FieldValues[1] - l.FieldValues[2]) * l.FieldValues[6] * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) + (sin(l.Point[1]) * (-(g.Parameters[0] * (4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] * l.FieldValues[5] - 2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[6][1] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[5] * l.DerivativeValues[3][0])) + pow(E, l.FieldValues[2]) * l.FieldValues[7] * sin(l.Point[1]) * (g.Parameters[0] * l.FieldValues[3] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) + l.VIEValues[0] * (4 * g.Parameters[0] * pow(E, l.FieldValues[1]) * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) * l.FieldValues[5] - 2 * pow(E, l.FieldValues[0]) * pow(-1 + l.Point[0], 2) * l.DerivativeValues[4][1]))) / (g.Parameters[0] * pow(E, l.FieldValues[0]))); });
    descriptor.SetJacobianComponent(1, 6, 0, 0, [](const auto& l, const auto& g) {return -0.5 * (pow(g.Parameters[1], 2) * pow(E, -l.FieldValues[0] + l.FieldValues[1] - l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * (-2 * pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.FieldValues[4] - 8 * pow(E, l.FieldValues[0] + l.FieldValues[1]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[5] - 2 * pow(E, l.FieldValues[2]) * l.FieldValues[6] * sin(l.Point[1]) * (-4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] + 4 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) + (2 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (2 * g.Parameters[0] * pow(E, l.FieldValues[0]) * l.DerivativeValues[5][0] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[7][0] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[4] * l.DerivativeValues[3][1]))) / g.Parameters[0])); });
    descriptor.SetJacobianComponent(1, 7, 0, 0, [](const auto& l, const auto& g) {return (pow(g.Parameters[1], 2) * pow(E, -l.FieldValues[0] + l.FieldValues[1] - l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * (-4 * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[4] + g.Parameters[0] * pow(E, l.FieldValues[2]) * l.FieldValues[7] * sin(l.Point[1]) * (-4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] + 4 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (g.Parameters[0] * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[3] * l.FieldValues[5] + 2 * g.Parameters[0] * pow(E, l.FieldValues[0]) * l.DerivativeValues[4][0] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[6][0] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[5] * l.DerivativeValues[3][1])))) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(1, 8, 0, 0, [](const auto& l, const auto& g) {return -2 * pow(g.Parameters[1], 2) * pow(E, -l.FieldValues[0] + 2 * l.FieldValues[1] - l.FieldValues[2]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * (pow(E, l.FieldValues[2]) * pow(l.FieldValues[6], 2) * sin(l.Point[1]) * l.FieldValues[3] + pow(E, l.FieldValues[2]) * pow(l.FieldValues[7], 2) * sin(l.Point[1]) * l.FieldValues[3] + 2 * pow(E, l.FieldValues[0]) * l.FieldValues[7] * l.FieldValues[4] - 2 * pow(E, l.FieldValues[0]) * l.FieldValues[6] * l.FieldValues[5] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[3] * (pow(l.FieldValues[4], 2) + pow(l.FieldValues[5], 2))); });
    descriptor.SetJacobianComponent(1, 9, 0, 0, [](const auto& l, const auto& g) {return -2 * pow(g.Parameters[1], 2) * pow(E, -l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * (pow(l.FieldValues[6], 2) + pow(l.FieldValues[7], 2) + pow(l.FieldValues[4], 2) + pow(l.FieldValues[5], 2)); });
    descriptor.SetJacobianComponent(1, 0, 1, 0, [](const auto& l, const auto& g) {return -(pow(sin(l.Point[1]), 2) * (cot(l.Point[1]) + l.DerivativeValues[2][0])); });
    descriptor.SetJacobianComponent(1, 0, 3, 0, [](const auto& l, const auto& g) {return -((pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * (g.Parameters[0] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[2][1])) / pow(g.Parameters[0], 2)); });
    descriptor.SetJacobianComponent(1, 1, 1, 0, [](const auto& l, const auto& g) {return pow(sin(l.Point[1]), 2); });
    descriptor.SetJacobianComponent(1, 1, 2, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (g.Parameters[0] + 2 * (-1 + l.Point[0]) * l.VIEValues[0]) * pow(sin(l.Point[1]), 2)) / pow(g.Parameters[0], 2); });
    descriptor.SetJacobianComponent(1, 1, 3, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 4) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2)) / pow(g.Parameters[0], 2); });
    descriptor.SetJacobianComponent(1, 2, 1, 0, [](const auto& l, const auto& g) {return -(pow(sin(l.Point[1]), 2) * l.DerivativeValues[0][0]); });
    descriptor.SetJacobianComponent(1, 2, 2, 0, [](const auto& l, const auto& g) {return -((pow(-1 + l.Point[0], 4) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.DerivativeValues[0][2]) / pow(g.Parameters[0], 2)); });
    descriptor.SetJacobianComponent(1, 3, 1, 0, [](const auto& l, const auto& g) {return -0.5 * (pow(E, -2 * l.FieldValues[0] + l.FieldValues[2]) * pow(sin(l.Point[1]), 3) * (-(pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * pow(l.FieldValues[6], 2) * l.VIEValues[0]) - pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * pow(l.FieldValues[7], 2) * l.VIEValues[0] + pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.VIEValues[0] * pow(l.FieldValues[4], 2) + pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.VIEValues[0] * pow(l.FieldValues[5], 2) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0])); });
    descriptor.SetJacobianComponent(1, 3, 2, 0, [](const auto& l, const auto& g) {return (pow(E, -2 * l.FieldValues[0] + l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 3) * (-2 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.VIEValues[0] * (l.FieldValues[6] * l.FieldValues[4] + l.FieldValues[7] * l.FieldValues[5]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (g.Parameters[0] * l.FieldValues[3] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]))) / (2. * pow(g.Parameters[0], 2)); });
    descriptor.SetJacobianComponent(1, 4, 1, 0, [](const auto& l, const auto& g) {return 2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * l.FieldValues[7] * l.VIEValues[0] * pow(sin(l.Point[1]), 2); });
    descriptor.SetJacobianComponent(1, 4, 2, 0, [](const auto& l, const auto& g) {return (-2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * pow(-1 + l.Point[0], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[5]) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(1, 5, 1, 0, [](const auto& l, const auto& g) {return -2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * l.FieldValues[6] * l.VIEValues[0] * pow(sin(l.Point[1]), 2); });
    descriptor.SetJacobianComponent(1, 5, 2, 0, [](const auto& l, const auto& g) {return (2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * pow(-1 + l.Point[0], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[4]) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(1, 6, 1, 0, [](const auto& l, const auto& g) {return (2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * pow(-1 + l.Point[0], 2) * l.FieldValues[7] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2)) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(1, 6, 2, 0, [](const auto& l, const auto& g) {return 2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[5]; });
    descriptor.SetJacobianComponent(1, 7, 1, 0, [](const auto& l, const auto& g) {return (-2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * pow(-1 + l.Point[0], 2) * l.FieldValues[6] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2)) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(1, 7, 2, 0, [](const auto& l, const auto& g) {return -2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[4]; });
    descriptor.SetJacobianComponent(1, 1, 2, 1, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(1, 1, 0, 2, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(1, 1, 0, 3, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(1, 2, 0, 3, [](const auto& l, const auto& g) {return -1; });
    descriptor.SetJacobianComponent(1, 1, 0, 4, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(1, 2, 0, 4, [](const auto& l, const auto& g) {return -1; });
    descriptor.SetJacobianComponent(2, 0, 0, 0, [](const auto& l, const auto& g) {return -0.5 * (pow(sin(l.Point[1]), 2) * (4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(l.FieldValues[8], 2) * pow(l.FieldValues[3], 2) + 2 * pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) + 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[2] * pow(l.VIEValues[0], 2) * pow(l.FieldValues[4], 2) - 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * l.FieldValues[9] * pow(l.FieldValues[4], 2) - 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[4] * l.VIEValues[0] * l.FieldValues[3] * pow(l.FieldValues[4], 2) - 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[3] * pow(l.FieldValues[4], 2) + 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[2] * pow(l.VIEValues[0], 2) * pow(l.FieldValues[5], 2) - 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * l.FieldValues[9] * pow(l.FieldValues[5], 2) - 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[4] * l.VIEValues[0] * l.FieldValues[3] * pow(l.FieldValues[5], 2) - 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[3] * pow(l.FieldValues[5], 2) + 8 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * l.FieldValues[8] * cos(l.Point[1]) * sin(l.Point[1]) * pow(l.FieldValues[3], 2) * l.DerivativeValues[8][0] + 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) * pow(l.DerivativeValues[8][0], 2) + 8 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * l.FieldValues[8] * cos(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[9][0] + 8 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] * l.DerivativeValues[9][0] + 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(l.DerivativeValues[9][0], 2) + 3 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * pow(l.FieldValues[4], 2) * l.DerivativeValues[3][0] + 3 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * pow(l.FieldValues[5], 2) * l.DerivativeValues[3][0] + 2 * pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.DerivativeValues[3][0], 2) + pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * pow(l.FieldValues[6], 2) * l.VIEValues[0] * (-4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] + 4 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) - 3 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) + pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * pow(l.FieldValues[7], 2) * l.VIEValues[0] * (-4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] + 4 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) - 3 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) + 8 * pow(g.Parameters[1], 2) * g.Parameters[0] * l.FieldValues[8] * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) * l.DerivativeValues[8][1] - 16 * pow(g.Parameters[1], 2) * g.Parameters[0] * l.Point[0] * l.FieldValues[8] * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) * l.DerivativeValues[8][1] + 8 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(l.Point[0], 2) * l.FieldValues[8] * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) * l.DerivativeValues[8][1] + 4 * pow(g.Parameters[1], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) * pow(l.DerivativeValues[8][1], 2) - 16 * pow(g.Parameters[1], 2) * l.Point[0] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) * pow(l.DerivativeValues[8][1], 2) + 24 * pow(g.Parameters[1], 2) * pow(l.Point[0], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) * pow(l.DerivativeValues[8][1], 2) - 16 * pow(g.Parameters[1], 2) * pow(l.Point[0], 3) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) * pow(l.DerivativeValues[8][1], 2) + 4 * pow(g.Parameters[1], 2) * pow(l.Point[0], 4) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) * pow(l.DerivativeValues[8][1], 2) + 8 * pow(g.Parameters[1], 2) * g.Parameters[0] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[9][1] - 16 * pow(g.Parameters[1], 2) * g.Parameters[0] * l.Point[0] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[9][1] + 8 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(l.Point[0], 2) * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[9][1] + 8 * pow(g.Parameters[1], 2) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] * l.DerivativeValues[9][1] - 32 * pow(g.Parameters[1], 2) * l.Point[0] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] * l.DerivativeValues[9][1] + 48 * pow(g.Parameters[1], 2) * pow(l.Point[0], 2) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] * l.DerivativeValues[9][1] - 32 * pow(g.Parameters[1], 2) * pow(l.Point[0], 3) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] * l.DerivativeValues[9][1] + 8 * pow(g.Parameters[1], 2) * pow(l.Point[0], 4) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] * l.DerivativeValues[9][1] + 4 * pow(g.Parameters[1], 2) * pow(l.VIEValues[0], 2) * pow(l.DerivativeValues[9][1], 2) - 16 * pow(g.Parameters[1], 2) * l.Point[0] * pow(l.VIEValues[0], 2) * pow(l.DerivativeValues[9][1], 2) + 24 * pow(g.Parameters[1], 2) * pow(l.Point[0], 2) * pow(l.VIEValues[0], 2) * pow(l.DerivativeValues[9][1], 2) - 16 * pow(g.Parameters[1], 2) * pow(l.Point[0], 3) * pow(l.VIEValues[0], 2) * pow(l.DerivativeValues[9][1], 2) + 4 * pow(g.Parameters[1], 2) * pow(l.Point[0], 4) * pow(l.VIEValues[0], 2) * pow(l.DerivativeValues[9][1], 2) - 4 * g.Parameters[0] * pow(E, 2 * l.FieldValues[2]) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.DerivativeValues[3][1] + 8 * g.Parameters[0] * pow(E, 2 * l.FieldValues[2]) * l.Point[0] * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.DerivativeValues[3][1] - 4 * g.Parameters[0] * pow(E, 2 * l.FieldValues[2]) * pow(l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.DerivativeValues[3][1] + 2 * pow(E, 2 * l.FieldValues[2]) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.DerivativeValues[3][1], 2) - 8 * pow(E, 2 * l.FieldValues[2]) * l.Point[0] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.DerivativeValues[3][1], 2) + 12 * pow(E, 2 * l.FieldValues[2]) * pow(l.Point[0], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.DerivativeValues[3][1], 2) - 8 * pow(E, 2 * l.FieldValues[2]) * pow(l.Point[0], 3) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.DerivativeValues[3][1], 2) + 2 * pow(E, 2 * l.FieldValues[2]) * pow(l.Point[0], 4) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * pow(l.DerivativeValues[3][1], 2) - 6 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[6] * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[4] * (g.Parameters[0] * l.FieldValues[3] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) - 6 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[7] * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[5] * (g.Parameters[0] * l.FieldValues[3] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]))) / (pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[0])); });
    descriptor.SetJacobianComponent(2, 1, 0, 0, [](const auto& l, const auto& g) {return -0.5 * (pow(g.Parameters[1], 2) * pow(E, -l.FieldValues[0] + l.FieldValues[1] - l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * (g.Parameters[0] * pow(E, l.FieldValues[2]) * pow(l.FieldValues[6], 2) * sin(l.Point[1]) * (8 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] - 8 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) + 3 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) + g.Parameters[0] * pow(E, l.FieldValues[2]) * pow(l.FieldValues[7], 2) * sin(l.Point[1]) * (8 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] - 8 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) + 3 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) + 2 * l.FieldValues[6] * (3 * g.Parameters[0] * pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.FieldValues[4] + 8 * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[5] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (2 * g.Parameters[0] * pow(E, l.FieldValues[0]) * l.DerivativeValues[5][0] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[7][0] + 3 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[4] * l.DerivativeValues[3][1]))) - 2 * l.FieldValues[7] * (8 * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[4] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (3 * g.Parameters[0] * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[3] * l.FieldValues[5] + 2 * g.Parameters[0] * pow(E, l.FieldValues[0]) * l.DerivativeValues[4][0] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[6][0] - 3 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[5] * l.DerivativeValues[3][1]))) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (g.Parameters[0] * (8 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] * (pow(l.FieldValues[4], 2) + pow(l.FieldValues[5], 2)) + 4 * pow(E, l.FieldValues[0]) * l.FieldValues[5] * l.DerivativeValues[6][1] - 4 * pow(E, l.FieldValues[0]) * l.FieldValues[4] * l.DerivativeValues[7][1] - 3 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * pow(l.FieldValues[4], 2) * l.DerivativeValues[3][0] - 3 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * pow(l.FieldValues[5], 2) * l.DerivativeValues[3][0]) + l.VIEValues[0] * (-8 * g.Parameters[0] * pow(E, l.FieldValues[1]) * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) * pow(l.FieldValues[4], 2) - 4 * l.FieldValues[5] * (2 * g.Parameters[0] * pow(E, l.FieldValues[1]) * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) * l.FieldValues[5] + pow(E, l.FieldValues[0]) * pow(-1 + l.Point[0], 2) * l.DerivativeValues[4][1]) + 4 * pow(E, l.FieldValues[0]) * pow(-1 + l.Point[0], 2) * l.FieldValues[4] * l.DerivativeValues[5][1])))) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(2, 2, 0, 0, [](const auto& l, const auto& g) {return (-4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[0]) * pow(l.FieldValues[8], 2) - 8 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, 2 * l.FieldValues[0]) * l.FieldValues[8] * sin(l.Point[1]) * (g.Parameters[0] * pow(E, 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[3] * l.FieldValues[7] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[4] - g.Parameters[0] * pow(E, 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[3] * l.FieldValues[6] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[5] + g.Parameters[0] * cos(l.Point[1]) * l.DerivativeValues[8][0] + l.VIEValues[0] * sin(l.Point[1]) * l.DerivativeValues[8][1] - 2 * l.Point[0] * l.VIEValues[0] * sin(l.Point[1]) * l.DerivativeValues[8][1] + pow(l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.DerivativeValues[8][1]) + sin(l.Point[1]) * (2 * pow(g.Parameters[0], 2) * pow(E, 4 * l.FieldValues[2]) * pow(sin(l.Point[1]), 3) * pow(l.FieldValues[3], 2) + 8 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[0] + 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[4] * l.FieldValues[6] * l.VIEValues[0] * l.FieldValues[5] - 4 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[0]) * sin(l.Point[1]) * pow(l.DerivativeValues[8][0], 2) - 3 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + 3 * l.FieldValues[2]) * pow(l.FieldValues[6], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.DerivativeValues[3][0] - 3 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + 3 * l.FieldValues[2]) * pow(l.FieldValues[7], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.DerivativeValues[3][0] + 3 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + 3 * l.FieldValues[2]) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[4], 2) * l.DerivativeValues[3][0] + 3 * pow(g.Parameters[1], 2) * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + 3 * l.FieldValues[2]) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[5], 2) * l.DerivativeValues[3][0] + 2 * pow(g.Parameters[0], 2) * pow(E, 4 * l.FieldValues[2]) * pow(sin(l.Point[1]), 3) * pow(l.DerivativeValues[3][0], 2) - 4 * pow(g.Parameters[1], 2) * pow(E, 2 * l.FieldValues[0]) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * pow(l.DerivativeValues[8][1], 2) + 16 * pow(g.Parameters[1], 2) * pow(E, 2 * l.FieldValues[0]) * l.Point[0] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * pow(l.DerivativeValues[8][1], 2) - 24 * pow(g.Parameters[1], 2) * pow(E, 2 * l.FieldValues[0]) * pow(l.Point[0], 2) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * pow(l.DerivativeValues[8][1], 2) + 16 * pow(g.Parameters[1], 2) * pow(E, 2 * l.FieldValues[0]) * pow(l.Point[0], 3) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * pow(l.DerivativeValues[8][1], 2) - 4 * pow(g.Parameters[1], 2) * pow(E, 2 * l.FieldValues[0]) * pow(l.Point[0], 4) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * pow(l.DerivativeValues[8][1], 2) + 6 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1] + 3 * l.FieldValues[2]) * l.FieldValues[6] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[4] * l.DerivativeValues[3][1] - 12 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1] + 3 * l.FieldValues[2]) * l.Point[0] * l.FieldValues[6] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[4] * l.DerivativeValues[3][1] + 6 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1] + 3 * l.FieldValues[2]) * pow(l.Point[0], 2) * l.FieldValues[6] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[4] * l.DerivativeValues[3][1] + 2 * pow(E, 4 * l.FieldValues[2]) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 3) * pow(l.DerivativeValues[3][1], 2) - 8 * pow(E, 4 * l.FieldValues[2]) * l.Point[0] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 3) * pow(l.DerivativeValues[3][1], 2) + 12 * pow(E, 4 * l.FieldValues[2]) * pow(l.Point[0], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 3) * pow(l.DerivativeValues[3][1], 2) - 8 * pow(E, 4 * l.FieldValues[2]) * pow(l.Point[0], 3) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 3) * pow(l.DerivativeValues[3][1], 2) + 2 * pow(E, 4 * l.FieldValues[2]) * pow(l.Point[0], 4) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 3) * pow(l.DerivativeValues[3][1], 2) - 2 * g.Parameters[0] * pow(E, 3 * l.FieldValues[2]) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * (3 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.FieldValues[6] * l.FieldValues[4] + 3 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.FieldValues[7] * l.FieldValues[5] + 2 * pow(E, l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * sin(l.Point[1]) * l.DerivativeValues[3][1]) + 2 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[7] * l.VIEValues[0] * (-4 * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[4] + 3 * pow(E, 2 * l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[5] * l.DerivativeValues[3][1]))) / (2. * pow(g.Parameters[0], 2) * pow(E, 2 * (l.FieldValues[0] + l.FieldValues[2]))); });
    descriptor.SetJacobianComponent(2, 3, 0, 0, [](const auto& l, const auto& g) {return (pow(sin(l.Point[1]), 2) * (-2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * pow(l.FieldValues[6], 2) * l.VIEValues[0] * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) - 2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * pow(l.FieldValues[7], 2) * l.VIEValues[0] * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) - 3 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[6] * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[4] - 3 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[7] * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[5] + (2 * pow(g.Parameters[1], 2) * (pow(g.Parameters[0], 2) * pow(l.FieldValues[8], 2) * l.FieldValues[3] - pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[4] * l.VIEValues[0] * (pow(l.FieldValues[4], 2) + pow(l.FieldValues[5], 2)) + pow(g.Parameters[0], 2) * sin(l.Point[1]) * l.DerivativeValues[8][0] * (sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] + l.DerivativeValues[9][0]) + pow(-1 + l.Point[0], 4) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.DerivativeValues[8][1] * (sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] + l.DerivativeValues[9][1]) - g.Parameters[0] * l.FieldValues[8] * (g.Parameters[0] * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * (pow(l.FieldValues[4], 2) + pow(l.FieldValues[5], 2)) - g.Parameters[0] * cos(l.Point[1]) * (2 * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] + l.DerivativeValues[9][0]) - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * (2 * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] + l.DerivativeValues[9][1])))) / pow(g.Parameters[0], 2) + pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * (l.FieldValues[3] - (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) / g.Parameters[0]))) / pow(E, 2 * l.FieldValues[0]); });
    descriptor.SetJacobianComponent(2, 4, 0, 0, [](const auto& l, const auto& g) {return (pow(g.Parameters[1], 2) * pow(E, -l.FieldValues[0] + l.FieldValues[1] - l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * (4 * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.FieldValues[7] * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (g.Parameters[0] * (4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] * l.FieldValues[4] - 2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[7][1] - 3 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[4] * l.DerivativeValues[3][0]) + 3 * pow(E, l.FieldValues[2]) * l.FieldValues[6] * sin(l.Point[1]) * (g.Parameters[0] * l.FieldValues[3] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) + l.VIEValues[0] * (-4 * g.Parameters[0] * pow(E, l.FieldValues[1]) * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) * l.FieldValues[4] + 2 * pow(E, l.FieldValues[0]) * pow(-1 + l.Point[0], 2) * l.DerivativeValues[5][1])))) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(2, 5, 0, 0, [](const auto& l, const auto& g) {return -((pow(g.Parameters[1], 2) * pow(E, -l.FieldValues[0] + l.FieldValues[1] - l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * (4 * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.FieldValues[6] * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (g.Parameters[0] * (4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] * l.FieldValues[5] + 2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[6][1] - 3 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[5] * l.DerivativeValues[3][0]) + 3 * pow(E, l.FieldValues[2]) * l.FieldValues[7] * sin(l.Point[1]) * (g.Parameters[0] * l.FieldValues[3] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) - 2 * l.VIEValues[0] * (2 * g.Parameters[0] * pow(E, l.FieldValues[1]) * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) * l.FieldValues[5] + pow(E, l.FieldValues[0]) * pow(-1 + l.Point[0], 2) * l.DerivativeValues[4][1])))) / g.Parameters[0]); });
    descriptor.SetJacobianComponent(2, 6, 0, 0, [](const auto& l, const auto& g) {return pow(g.Parameters[1], 2) * pow(E, -l.FieldValues[0] + l.FieldValues[1] - l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * (-3 * pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.FieldValues[4] - 4 * pow(E, l.FieldValues[0] + l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[5] - 4 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) * (pow(E, l.FieldValues[2]) * l.FieldValues[6] * sin(l.Point[1]) * l.FieldValues[3] + pow(E, l.FieldValues[0]) * l.FieldValues[5]) - pow(E, l.FieldValues[2]) * l.FieldValues[6] * sin(l.Point[1]) * (-4 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9]) + 4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] + 3 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) + (pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (2 * g.Parameters[0] * pow(E, l.FieldValues[0]) * l.DerivativeValues[5][0] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[7][0] + 3 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[4] * l.DerivativeValues[3][1]))) / g.Parameters[0]); });
    descriptor.SetJacobianComponent(2, 7, 0, 0, [](const auto& l, const auto& g) {return -((pow(g.Parameters[1], 2) * pow(E, -l.FieldValues[0] + l.FieldValues[1] - l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * (-4 * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[4] + g.Parameters[0] * pow(E, l.FieldValues[2]) * l.FieldValues[7] * sin(l.Point[1]) * (4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] - 4 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) + 3 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (3 * g.Parameters[0] * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[3] * l.FieldValues[5] + 2 * g.Parameters[0] * pow(E, l.FieldValues[0]) * l.DerivativeValues[4][0] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (2 * pow(E, l.FieldValues[0]) * l.DerivativeValues[6][0] - 3 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[5] * l.DerivativeValues[3][1])))) / g.Parameters[0]); });
    descriptor.SetJacobianComponent(2, 8, 0, 0, [](const auto& l, const auto& g) {return (pow(g.Parameters[1], 2) * (4 * l.FieldValues[8] * (pow(E, 2 * l.FieldValues[0]) + pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2)) + 4 * sin(l.Point[1]) * (-(pow(E, l.FieldValues[0] + 2 * (l.FieldValues[1] + l.FieldValues[2])) * g.Parameters[3] * pow(l.FieldValues[6], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[3]) - pow(E, l.FieldValues[0] + 2 * (l.FieldValues[1] + l.FieldValues[2])) * g.Parameters[3] * pow(l.FieldValues[7], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] + 2 * pow(E, 2 * l.FieldValues[0] + 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[3] * l.FieldValues[7] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[4] - pow(E, l.FieldValues[0] + 2 * (l.FieldValues[1] + l.FieldValues[2])) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * pow(l.FieldValues[4], 2) - 2 * pow(E, 2 * l.FieldValues[0] + 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[3] * l.FieldValues[6] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.FieldValues[5] - pow(E, l.FieldValues[0] + 2 * (l.FieldValues[1] + l.FieldValues[2])) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * pow(l.FieldValues[5], 2) + pow(E, 2 * l.FieldValues[0]) * cos(l.Point[1]) * l.DerivativeValues[8][0] + pow(E, 2 * l.FieldValues[2]) * cos(l.Point[1]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) * l.DerivativeValues[8][0] + pow(E, 2 * l.FieldValues[2]) * cos(l.Point[1]) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[9][0] + (pow(E, 2 * l.FieldValues[0]) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.DerivativeValues[8][1]) / g.Parameters[0] + (pow(E, 2 * l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 3) * pow(l.FieldValues[3], 2) * l.DerivativeValues[8][1]) / g.Parameters[0] + (pow(E, 2 * l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.DerivativeValues[9][1]) / g.Parameters[0]))) / (2. * pow(E, 2 * (l.FieldValues[0] + l.FieldValues[2]))); });
    descriptor.SetJacobianComponent(2, 9, 0, 0, [](const auto& l, const auto& g) {return -2 * pow(g.Parameters[1], 2) * pow(E, -l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * (pow(l.FieldValues[6], 2) + pow(l.FieldValues[7], 2) + pow(l.FieldValues[4], 2) + pow(l.FieldValues[5], 2)); });
    descriptor.SetJacobianComponent(2, 0, 1, 0, [](const auto& l, const auto& g) {return sin(l.Point[1]) * (cos(l.Point[1]) + sin(l.Point[1]) * l.DerivativeValues[2][0]); });
    descriptor.SetJacobianComponent(2, 0, 3, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * (g.Parameters[0] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[2][1])) / pow(g.Parameters[0], 2); });
    descriptor.SetJacobianComponent(2, 2, 1, 0, [](const auto& l, const auto& g) {return sin(l.Point[1]) * (sin(l.Point[1]) * l.DerivativeValues[0][0] + 2 * (cos(l.Point[1]) + sin(l.Point[1]) * l.DerivativeValues[2][0])); });
    descriptor.SetJacobianComponent(2, 2, 2, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * (3 * g.Parameters[0] + (-1 + l.Point[0]) * l.VIEValues[0] * (2 + (-1 + l.Point[0]) * l.DerivativeValues[0][2] + 2 * (-1 + l.Point[0]) * l.DerivativeValues[2][1]))) / pow(g.Parameters[0], 2); });
    descriptor.SetJacobianComponent(2, 2, 3, 0, [](const auto& l, const auto& g) {return pow(sin(l.Point[1]), 2); });
    descriptor.SetJacobianComponent(2, 2, 4, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 4) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2)) / pow(g.Parameters[0], 2); });
    descriptor.SetJacobianComponent(2, 3, 1, 0, [](const auto& l, const auto& g) {return (pow(E, -2 * l.FieldValues[0] + l.FieldValues[2]) * pow(sin(l.Point[1]), 3) * (-3 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * pow(l.FieldValues[6], 2) * l.VIEValues[0] - 3 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * pow(l.FieldValues[7], 2) * l.VIEValues[0] + 3 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.VIEValues[0] * pow(l.FieldValues[4], 2) + 3 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.VIEValues[0] * pow(l.FieldValues[5], 2) + 2 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0])) / 2.; });
    descriptor.SetJacobianComponent(2, 3, 2, 0, [](const auto& l, const auto& g) {return (pow(E, -2 * l.FieldValues[0] + l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 3) * (-(g.Parameters[0] * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[3]) + l.VIEValues[0] * (3 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.FieldValues[6] * l.FieldValues[4] + 3 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.FieldValues[7] * l.FieldValues[5] + pow(E, l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * sin(l.Point[1]) * l.DerivativeValues[3][1]))) / pow(g.Parameters[0], 2); });
    descriptor.SetJacobianComponent(2, 4, 1, 0, [](const auto& l, const auto& g) {return -2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * l.FieldValues[7] * l.VIEValues[0] * pow(sin(l.Point[1]), 2); });
    descriptor.SetJacobianComponent(2, 4, 2, 0, [](const auto& l, const auto& g) {return (2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * pow(-1 + l.Point[0], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[5]) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(2, 5, 1, 0, [](const auto& l, const auto& g) {return 2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * l.FieldValues[6] * l.VIEValues[0] * pow(sin(l.Point[1]), 2); });
    descriptor.SetJacobianComponent(2, 5, 2, 0, [](const auto& l, const auto& g) {return (-2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * pow(-1 + l.Point[0], 2) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[4]) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(2, 6, 1, 0, [](const auto& l, const auto& g) {return (-2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * pow(-1 + l.Point[0], 2) * l.FieldValues[7] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2)) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(2, 6, 2, 0, [](const auto& l, const auto& g) {return -2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[5]; });
    descriptor.SetJacobianComponent(2, 7, 1, 0, [](const auto& l, const auto& g) {return (2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * pow(-1 + l.Point[0], 2) * l.FieldValues[6] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2)) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(2, 7, 2, 0, [](const auto& l, const auto& g) {return 2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1]) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[4]; });
    descriptor.SetJacobianComponent(2, 8, 1, 0, [](const auto& l, const auto& g) {return (2 * pow(g.Parameters[1], 2) * sin(l.Point[1]) * (l.FieldValues[8] * cos(l.Point[1]) * (pow(E, 2 * l.FieldValues[0]) + pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2)) + sin(l.Point[1]) * ((pow(E, 2 * l.FieldValues[0]) + pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2)) * l.DerivativeValues[8][0] + pow(E, 2 * l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[9][0]))) / pow(E, 2 * (l.FieldValues[0] + l.FieldValues[2])); });
    descriptor.SetJacobianComponent(2, 8, 2, 0, [](const auto& l, const auto& g) {return (2 * pow(g.Parameters[1], 2) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * (g.Parameters[0] * l.FieldValues[8] * (pow(E, 2 * l.FieldValues[0]) + pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2)) + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * ((pow(E, 2 * l.FieldValues[0]) + pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2)) * l.DerivativeValues[8][1] + pow(E, 2 * l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[9][1]))) / (pow(g.Parameters[0], 2) * pow(E, 2 * (l.FieldValues[0] + l.FieldValues[2]))); });
    descriptor.SetJacobianComponent(2, 9, 1, 0, [](const auto& l, const auto& g) {return (2 * pow(g.Parameters[1], 2) * pow(sin(l.Point[1]), 2) * (l.FieldValues[8] * cos(l.Point[1]) * l.FieldValues[3] + sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] + l.DerivativeValues[9][0])) / pow(E, 2 * l.FieldValues[0]); });
    descriptor.SetJacobianComponent(2, 9, 2, 0, [](const auto& l, const auto& g) {return (2 * pow(g.Parameters[1], 2) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * (g.Parameters[0] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] + l.DerivativeValues[9][1]))) / (pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[0])); });
    descriptor.SetJacobianComponent(2, 2, 2, 1, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(2, 2, 0, 2, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(2, 2, 1, 3, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(2, 2, 1, 4, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(3, 0, 0, 0, [](const auto& l, const auto& g) {return (2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] - 2 * l.FieldValues[2]) * l.VIEValues[0] * (g.Parameters[0] * pow(l.FieldValues[6], 2) * (2 * pow(E, l.FieldValues[1]) * g.Parameters[4] - pow(E, l.FieldValues[2]) * cos(l.Point[1]) + 2 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[0][0] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[2][0]) + g.Parameters[0] * pow(l.FieldValues[7], 2) * (2 * pow(E, l.FieldValues[1]) * g.Parameters[4] - pow(E, l.FieldValues[2]) * cos(l.Point[1]) + 2 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[0][0] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[2][0]) + g.Parameters[0] * (pow(l.FieldValues[4], 2) + pow(l.FieldValues[5], 2)) * (2 * pow(E, l.FieldValues[1]) * g.Parameters[4] + pow(E, l.FieldValues[2]) * cos(l.Point[1]) + 2 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[0][0] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[2][0]) + 2 * pow(E, l.FieldValues[2]) * l.FieldValues[6] * sin(l.Point[1]) * l.FieldValues[4] * (g.Parameters[0] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (l.DerivativeValues[0][2] - l.DerivativeValues[2][1])) + 2 * pow(E, l.FieldValues[2]) * l.FieldValues[7] * sin(l.Point[1]) * l.FieldValues[5] * (g.Parameters[0] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (l.DerivativeValues[0][2] - l.DerivativeValues[2][1])))) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(3, 1, 0, 0, [](const auto& l, const auto& g) {return (2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1] - 2 * l.FieldValues[2]) * l.VIEValues[0] * (g.Parameters[0] * pow(E, l.FieldValues[0]) * pow(l.FieldValues[6], 2) * (4 * pow(E, l.FieldValues[1]) * g.Parameters[4] - pow(E, l.FieldValues[2]) * cos(l.Point[1]) + 4 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[0][0] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[2][0]) + g.Parameters[0] * pow(E, l.FieldValues[0]) * pow(l.FieldValues[7], 2) * (4 * pow(E, l.FieldValues[1]) * g.Parameters[4] - pow(E, l.FieldValues[2]) * cos(l.Point[1]) + 4 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[0][0] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[2][0]) + g.Parameters[0] * pow(E, l.FieldValues[0]) * (pow(l.FieldValues[4], 2) + pow(l.FieldValues[5], 2)) * (4 * pow(E, l.FieldValues[1]) * g.Parameters[4] + pow(E, l.FieldValues[2]) * cos(l.Point[1]) + 4 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[0][0] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[2][0]) + 2 * pow(E, l.FieldValues[2]) * l.FieldValues[6] * sin(l.Point[1]) * (4 * g.Parameters[0] * pow(E, l.FieldValues[1]) * (g.Parameters[4] * l.FieldValues[3] + l.VIEValues[0] * (-g.Parameters[2] + g.Parameters[3] * l.FieldValues[9] + g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3])) * l.FieldValues[5] + pow(E, l.FieldValues[0]) * l.FieldValues[4] * (g.Parameters[0] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (l.DerivativeValues[0][2] - l.DerivativeValues[2][1]))) + 2 * pow(E, l.FieldValues[2]) * l.FieldValues[7] * sin(l.Point[1]) * (-4 * g.Parameters[0] * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] * l.FieldValues[4] + g.Parameters[0] * pow(E, l.FieldValues[0]) * l.FieldValues[5] + l.VIEValues[0] * (4 * g.Parameters[0] * pow(E, l.FieldValues[1]) * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) * l.FieldValues[4] - pow(E, l.FieldValues[0]) * pow(-1 + l.Point[0], 2) * l.FieldValues[5] * (l.DerivativeValues[0][2] - l.DerivativeValues[2][1]))))) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(3, 2, 0, 0, [](const auto& l, const auto& g) {return (-2 * pow(g.Parameters[1], 2) * (-4 * pow(g.Parameters[0], 2) * pow(l.FieldValues[8], 2) * l.FieldValues[3] + 4 * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[4] * l.VIEValues[0] * pow(l.FieldValues[4], 2) + pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * cos(l.Point[1]) * l.VIEValues[0] * pow(l.FieldValues[4], 2) + 4 * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * pow(l.FieldValues[4], 2) + 4 * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[4] * l.VIEValues[0] * pow(l.FieldValues[5], 2) + pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * cos(l.Point[1]) * l.VIEValues[0] * pow(l.FieldValues[5], 2) + 4 * pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * pow(l.FieldValues[5], 2) - 4 * pow(g.Parameters[0], 2) * l.FieldValues[8] * sin(2 * l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] - 2 * pow(g.Parameters[0], 2) * l.FieldValues[3] * pow(l.DerivativeValues[8][0], 2) + 2 * pow(g.Parameters[0], 2) * cos(2 * l.Point[1]) * l.FieldValues[3] * pow(l.DerivativeValues[8][0], 2) - pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * pow(l.FieldValues[4], 2) * l.DerivativeValues[0][0] - pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * pow(l.FieldValues[5], 2) * l.DerivativeValues[0][0] + pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * pow(l.FieldValues[4], 2) * l.DerivativeValues[2][0] + pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * l.VIEValues[0] * sin(l.Point[1]) * pow(l.FieldValues[5], 2) * l.DerivativeValues[2][0] + pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * pow(l.FieldValues[6], 2) * l.VIEValues[0] * (4 * pow(E, l.FieldValues[1]) * g.Parameters[4] - pow(E, l.FieldValues[2]) * cos(l.Point[1]) + 4 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[0][0] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[2][0]) + pow(g.Parameters[0], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * pow(l.FieldValues[7], 2) * l.VIEValues[0] * (4 * pow(E, l.FieldValues[1]) * g.Parameters[4] - pow(E, l.FieldValues[2]) * cos(l.Point[1]) + 4 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[0][0] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[2][0]) - 4 * pow(g.Parameters[0], 2) * l.FieldValues[8] * cos(l.Point[1]) * l.DerivativeValues[9][0] - 4 * pow(g.Parameters[0], 2) * sin(l.Point[1]) * l.DerivativeValues[8][0] * l.DerivativeValues[9][0] - 4 * g.Parameters[0] * l.FieldValues[8] * l.VIEValues[0] * l.FieldValues[3] * l.DerivativeValues[8][1] + 8 * g.Parameters[0] * l.Point[0] * l.FieldValues[8] * l.VIEValues[0] * l.FieldValues[3] * l.DerivativeValues[8][1] - 4 * g.Parameters[0] * pow(l.Point[0], 2) * l.FieldValues[8] * l.VIEValues[0] * l.FieldValues[3] * l.DerivativeValues[8][1] + 4 * g.Parameters[0] * l.FieldValues[8] * cos(2 * l.Point[1]) * l.VIEValues[0] * l.FieldValues[3] * l.DerivativeValues[8][1] - 8 * g.Parameters[0] * l.Point[0] * l.FieldValues[8] * cos(2 * l.Point[1]) * l.VIEValues[0] * l.FieldValues[3] * l.DerivativeValues[8][1] + 4 * g.Parameters[0] * pow(l.Point[0], 2) * l.FieldValues[8] * cos(2 * l.Point[1]) * l.VIEValues[0] * l.FieldValues[3] * l.DerivativeValues[8][1] - 2 * pow(l.VIEValues[0], 2) * l.FieldValues[3] * pow(l.DerivativeValues[8][1], 2) + 8 * l.Point[0] * pow(l.VIEValues[0], 2) * l.FieldValues[3] * pow(l.DerivativeValues[8][1], 2) - 12 * pow(l.Point[0], 2) * pow(l.VIEValues[0], 2) * l.FieldValues[3] * pow(l.DerivativeValues[8][1], 2) + 8 * pow(l.Point[0], 3) * pow(l.VIEValues[0], 2) * l.FieldValues[3] * pow(l.DerivativeValues[8][1], 2) - 2 * pow(l.Point[0], 4) * pow(l.VIEValues[0], 2) * l.FieldValues[3] * pow(l.DerivativeValues[8][1], 2) + 2 * cos(2 * l.Point[1]) * pow(l.VIEValues[0], 2) * l.FieldValues[3] * pow(l.DerivativeValues[8][1], 2) - 8 * l.Point[0] * cos(2 * l.Point[1]) * pow(l.VIEValues[0], 2) * l.FieldValues[3] * pow(l.DerivativeValues[8][1], 2) + 12 * pow(l.Point[0], 2) * cos(2 * l.Point[1]) * pow(l.VIEValues[0], 2) * l.FieldValues[3] * pow(l.DerivativeValues[8][1], 2) - 8 * pow(l.Point[0], 3) * cos(2 * l.Point[1]) * pow(l.VIEValues[0], 2) * l.FieldValues[3] * pow(l.DerivativeValues[8][1], 2) + 2 * pow(l.Point[0], 4) * cos(2 * l.Point[1]) * pow(l.VIEValues[0], 2) * l.FieldValues[3] * pow(l.DerivativeValues[8][1], 2) + 2 * g.Parameters[0] * pow(E, l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[6] * l.VIEValues[0] * sin(l.Point[1]) * (2 * g.Parameters[0] * pow(E, l.FieldValues[1]) * (g.Parameters[4] * l.FieldValues[3] + l.VIEValues[0] * (-g.Parameters[2] + g.Parameters[3] * l.FieldValues[9] + g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3])) * l.FieldValues[5] + pow(E, l.FieldValues[0]) * l.FieldValues[4] * (g.Parameters[0] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (l.DerivativeValues[0][2] - l.DerivativeValues[2][1]))) + 2 * g.Parameters[0] * pow(E, l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[7] * l.VIEValues[0] * sin(l.Point[1]) * (-2 * g.Parameters[0] * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] * l.FieldValues[4] + g.Parameters[0] * pow(E, l.FieldValues[0]) * l.FieldValues[5] + l.VIEValues[0] * (2 * g.Parameters[0] * pow(E, l.FieldValues[1]) * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) * l.FieldValues[4] - pow(E, l.FieldValues[0]) * pow(-1 + l.Point[0], 2) * l.FieldValues[5] * (l.DerivativeValues[0][2] - l.DerivativeValues[2][1]))) - 4 * g.Parameters[0] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) * l.DerivativeValues[9][1] + 8 * g.Parameters[0] * l.Point[0] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) * l.DerivativeValues[9][1] - 4 * g.Parameters[0] * pow(l.Point[0], 2) * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) * l.DerivativeValues[9][1] - 4 * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.DerivativeValues[8][1] * l.DerivativeValues[9][1] + 16 * l.Point[0] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.DerivativeValues[8][1] * l.DerivativeValues[9][1] - 24 * pow(l.Point[0], 2) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.DerivativeValues[8][1] * l.DerivativeValues[9][1] + 16 * pow(l.Point[0], 3) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.DerivativeValues[8][1] * l.DerivativeValues[9][1] - 4 * pow(l.Point[0], 4) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * l.DerivativeValues[8][1] * l.DerivativeValues[9][1])) / (pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[2])); });
    descriptor.SetJacobianComponent(3, 3, 0, 0, [](const auto& l, const auto& g) {return -(((2 * pow(g.Parameters[1], 2) * (2 * pow(g.Parameters[0], 2) * pow(l.FieldValues[8], 2) + 4 * pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[7] * l.VIEValues[0] * sin(l.Point[1]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[4] - 4 * pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[6] * l.VIEValues[0] * sin(l.Point[1]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[5] + 2 * pow(g.Parameters[0], 2) * l.FieldValues[8] * sin(2 * l.Point[1]) * l.DerivativeValues[8][0] + pow(g.Parameters[0], 2) * pow(l.DerivativeValues[8][0], 2) - pow(g.Parameters[0], 2) * cos(2 * l.Point[1]) * pow(l.DerivativeValues[8][0], 2) + 2 * g.Parameters[0] * pow(-1 + l.Point[0], 2) * l.FieldValues[8] * l.VIEValues[0] * l.DerivativeValues[8][1] - 2 * g.Parameters[0] * pow(-1 + l.Point[0], 2) * l.FieldValues[8] * cos(2 * l.Point[1]) * l.VIEValues[0] * l.DerivativeValues[8][1] + pow(-1 + l.Point[0], 4) * pow(l.VIEValues[0], 2) * pow(l.DerivativeValues[8][1], 2) - pow(-1 + l.Point[0], 4) * cos(2 * l.Point[1]) * pow(l.VIEValues[0], 2) * pow(l.DerivativeValues[8][1], 2))) / pow(E, 2 * l.FieldValues[2]) + g.Parameters[0] * pow(sin(l.Point[1]), 2) * (2 * g.Parameters[0] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[0][2] + 3 * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[2][1])) / pow(g.Parameters[0], 2)); });
    descriptor.SetJacobianComponent(3, 4, 0, 0, [](const auto& l, const auto& g) {return (-4 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1] - 2 * l.FieldValues[2]) * l.VIEValues[0] * (2 * g.Parameters[0] * pow(E, l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[7] * sin(l.Point[1]) * (g.Parameters[4] * l.FieldValues[3] + l.VIEValues[0] * (-g.Parameters[2] + g.Parameters[3] * l.FieldValues[9] + g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3])) - g.Parameters[0] * pow(E, l.FieldValues[0]) * l.FieldValues[4] * (2 * pow(E, l.FieldValues[1]) * g.Parameters[4] + pow(E, l.FieldValues[2]) * cos(l.Point[1]) + 2 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[0][0] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[2][0]) - pow(E, l.FieldValues[0] + l.FieldValues[2]) * l.FieldValues[6] * sin(l.Point[1]) * (g.Parameters[0] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (l.DerivativeValues[0][2] - l.DerivativeValues[2][1])))) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(3, 5, 0, 0, [](const auto& l, const auto& g) {return (4 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1] - 2 * l.FieldValues[2]) * l.VIEValues[0] * (g.Parameters[0] * (2 * pow(E, l.FieldValues[1] + l.FieldValues[2]) * l.FieldValues[6] * sin(l.Point[1]) * (g.Parameters[4] * l.FieldValues[3] + l.VIEValues[0] * (-g.Parameters[2] + g.Parameters[3] * l.FieldValues[9] + g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3])) + pow(E, l.FieldValues[0]) * l.FieldValues[5] * (2 * pow(E, l.FieldValues[1]) * g.Parameters[4] + pow(E, l.FieldValues[2]) * cos(l.Point[1]) + 2 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[0][0] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[2][0])) + pow(E, l.FieldValues[0] + l.FieldValues[2]) * l.FieldValues[7] * sin(l.Point[1]) * (g.Parameters[0] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (l.DerivativeValues[0][2] - l.DerivativeValues[2][1])))) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(3, 6, 0, 0, [](const auto& l, const auto& g) {return (4 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1] - 2 * l.FieldValues[2]) * l.VIEValues[0] * (g.Parameters[0] * pow(E, l.FieldValues[0]) * l.FieldValues[6] * (2 * pow(E, l.FieldValues[1]) * g.Parameters[4] - pow(E, l.FieldValues[2]) * cos(l.Point[1]) + 2 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[0][0] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[2][0]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (2 * g.Parameters[0] * pow(E, l.FieldValues[1]) * (g.Parameters[4] * l.FieldValues[3] + l.VIEValues[0] * (-g.Parameters[2] + g.Parameters[3] * l.FieldValues[9] + g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3])) * l.FieldValues[5] + pow(E, l.FieldValues[0]) * l.FieldValues[4] * (g.Parameters[0] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (l.DerivativeValues[0][2] - l.DerivativeValues[2][1]))))) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(3, 7, 0, 0, [](const auto& l, const auto& g) {return (4 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[1] - 2 * l.FieldValues[2]) * l.VIEValues[0] * (g.Parameters[0] * pow(E, l.FieldValues[0]) * l.FieldValues[7] * (2 * pow(E, l.FieldValues[1]) * g.Parameters[4] - pow(E, l.FieldValues[2]) * cos(l.Point[1]) + 2 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[0][0] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[2][0]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * (-2 * g.Parameters[0] * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] * l.FieldValues[4] + g.Parameters[0] * pow(E, l.FieldValues[0]) * l.FieldValues[5] + l.VIEValues[0] * (2 * g.Parameters[0] * pow(E, l.FieldValues[1]) * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) * l.FieldValues[4] - pow(E, l.FieldValues[0]) * pow(-1 + l.Point[0], 2) * l.FieldValues[5] * (l.DerivativeValues[0][2] - l.DerivativeValues[2][1]))))) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(3, 8, 0, 0, [](const auto& l, const auto& g) {return (4 * pow(g.Parameters[1], 2) * (pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.FieldValues[6], 2) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) + pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.FieldValues[7], 2) * pow(l.VIEValues[0], 2) * sin(l.Point[1]) - 2 * l.FieldValues[8] * l.FieldValues[3] - 2 * pow(E, 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[3] * l.FieldValues[7] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.FieldValues[4] + pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * pow(l.FieldValues[4], 2) + 2 * pow(E, 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[3] * l.FieldValues[6] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * l.FieldValues[5] + pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * pow(l.FieldValues[5], 2) - sin(2 * l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] - cos(l.Point[1]) * l.DerivativeValues[9][0] - (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.FieldValues[3] * l.DerivativeValues[8][1]) / g.Parameters[0] + (pow(-1 + l.Point[0], 2) * cos(2 * l.Point[1]) * l.VIEValues[0] * l.FieldValues[3] * l.DerivativeValues[8][1]) / g.Parameters[0] - (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.DerivativeValues[9][1]) / g.Parameters[0])) / pow(E, 2 * l.FieldValues[2]); });
    descriptor.SetJacobianComponent(3, 9, 0, 0, [](const auto& l, const auto& g) {return -8 * pow(g.Parameters[1], 2) * pow(E, 2 * l.FieldValues[1] - l.FieldValues[2]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * (l.FieldValues[7] * l.FieldValues[4] - l.FieldValues[6] * l.FieldValues[5]); });
    descriptor.SetJacobianComponent(3, 0, 1, 0, [](const auto& l, const auto& g) {return -((sin(l.Point[1]) * (-2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * pow(l.FieldValues[6], 2) * l.VIEValues[0] - 2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * pow(l.FieldValues[7], 2) * l.VIEValues[0] + 2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.VIEValues[0] * pow(l.FieldValues[4], 2) + 2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.VIEValues[0] * pow(l.FieldValues[5], 2) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0])) / pow(E, l.FieldValues[2])); });
    descriptor.SetJacobianComponent(3, 0, 3, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * (-4 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1] - l.FieldValues[2]) * l.VIEValues[0] * (l.FieldValues[6] * l.FieldValues[4] + l.FieldValues[7] * l.FieldValues[5]) + sin(l.Point[1]) * (g.Parameters[0] * l.FieldValues[3] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]))) / pow(g.Parameters[0], 2); });
    descriptor.SetJacobianComponent(3, 2, 1, 0, [](const auto& l, const auto& g) {return (sin(l.Point[1]) * (-2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * pow(l.FieldValues[6], 2) * l.VIEValues[0] - 2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * pow(l.FieldValues[7], 2) * l.VIEValues[0] + 2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.VIEValues[0] * pow(l.FieldValues[4], 2) + 2 * pow(g.Parameters[1], 2) * pow(E, l.FieldValues[0] + l.FieldValues[1]) * l.VIEValues[0] * pow(l.FieldValues[5], 2) + 3 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0])) / pow(E, l.FieldValues[2]); });
    descriptor.SetJacobianComponent(3, 2, 2, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * (4 * pow(g.Parameters[1], 2) * g.Parameters[0] * pow(E, l.FieldValues[0] + l.FieldValues[1] - l.FieldValues[2]) * l.VIEValues[0] * (l.FieldValues[6] * l.FieldValues[4] + l.FieldValues[7] * l.FieldValues[5]) - 3 * sin(l.Point[1]) * (g.Parameters[0] * l.FieldValues[3] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]))) / pow(g.Parameters[0], 2); });
    descriptor.SetJacobianComponent(3, 3, 1, 0, [](const auto& l, const auto& g) {return sin(l.Point[1]) * (-(sin(l.Point[1]) * l.DerivativeValues[0][0]) + 3 * (cos(l.Point[1]) + sin(l.Point[1]) * l.DerivativeValues[2][0])); });
    descriptor.SetJacobianComponent(3, 3, 2, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * (2 * g.Parameters[0] - (-1 + l.Point[0]) * l.VIEValues[0] * (-2 + (-1 + l.Point[0]) * l.DerivativeValues[0][2] - 3 * (-1 + l.Point[0]) * l.DerivativeValues[2][1]))) / pow(g.Parameters[0], 2); });
    descriptor.SetJacobianComponent(3, 3, 3, 0, [](const auto& l, const auto& g) {return pow(sin(l.Point[1]), 2); });
    descriptor.SetJacobianComponent(3, 3, 4, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 4) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2)) / pow(g.Parameters[0], 2); });
    descriptor.SetJacobianComponent(3, 8, 1, 0, [](const auto& l, const auto& g) {return (-4 * pow(g.Parameters[1], 2) * (l.FieldValues[8] * sin(2 * l.Point[1]) * l.FieldValues[3] - (-1 + cos(2 * l.Point[1])) * l.FieldValues[3] * l.DerivativeValues[8][0] + sin(l.Point[1]) * l.DerivativeValues[9][0])) / pow(E, 2 * l.FieldValues[2]); });
    descriptor.SetJacobianComponent(3, 8, 2, 0, [](const auto& l, const auto& g) {return (4 * pow(g.Parameters[1], 2) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (g.Parameters[0] * l.FieldValues[8] * (-1 + cos(2 * l.Point[1])) * l.FieldValues[3] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * ((-1 + cos(2 * l.Point[1])) * l.FieldValues[3] * l.DerivativeValues[8][1] - sin(l.Point[1]) * l.DerivativeValues[9][1]))) / (pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[2])); });
    descriptor.SetJacobianComponent(3, 9, 1, 0, [](const auto& l, const auto& g) {return (-4 * pow(g.Parameters[1], 2) * (l.FieldValues[8] * cos(l.Point[1]) + sin(l.Point[1]) * l.DerivativeValues[8][0])) / pow(E, 2 * l.FieldValues[2]); });
    descriptor.SetJacobianComponent(3, 9, 2, 0, [](const auto& l, const auto& g) {return (-4 * pow(g.Parameters[1], 2) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * (g.Parameters[0] * l.FieldValues[8] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[8][1])) / (pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[2])); });
    descriptor.SetJacobianComponent(3, 3, 0, 1, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(3, 2, 0, 2, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(3, 3, 1, 3, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(3, 3, 1, 4, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(4, 0, 0, 0, [](const auto& l, const auto& g) {return (sin(l.Point[1]) * (-(g.Parameters[0] * l.FieldValues[5] * (-4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] + 4 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0])) + pow(E, l.FieldValues[2]) * l.FieldValues[7] * sin(l.Point[1]) * (g.Parameters[0] * l.FieldValues[3] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]))) / (4. * g.Parameters[0] * pow(E, l.FieldValues[0])); });
    descriptor.SetJacobianComponent(4, 1, 0, 0, [](const auto& l, const auto& g) {return pow(E, l.FieldValues[1]) * ((l.FieldValues[6] * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]))) / pow(E, l.FieldValues[2]) - (sin(l.Point[1]) * (g.Parameters[4] * l.FieldValues[3] * l.FieldValues[5] + l.VIEValues[0] * (-(pow(E, l.FieldValues[0]) * g.Parameters[5] * l.FieldValues[4]) + (-g.Parameters[2] + g.Parameters[3] * l.FieldValues[9] + g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) * l.FieldValues[5]))) / pow(E, l.FieldValues[0])); });
    descriptor.SetJacobianComponent(4, 2, 0, 0, [](const auto& l, const auto& g) {return -(pow(E, l.FieldValues[1] - l.FieldValues[2]) * l.FieldValues[6] * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]))) + (pow(E, -l.FieldValues[0] + l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * (g.Parameters[0] * l.FieldValues[5] * l.DerivativeValues[3][0] + l.FieldValues[7] * (-(g.Parameters[0] * l.FieldValues[3]) + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]))) / (4. * g.Parameters[0]); });
    descriptor.SetJacobianComponent(4, 3, 0, 0, [](const auto& l, const auto& g) {return -0.25 * (sin(l.Point[1]) * (pow(E, l.FieldValues[2]) * l.FieldValues[7] * sin(l.Point[1]) + 4 * pow(E, l.FieldValues[1]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[5])) / pow(E, l.FieldValues[0]); });
    descriptor.SetJacobianComponent(4, 4, 0, 0, [](const auto& l, const auto& g) {return sin(l.Point[1]) + (l.VIEValues[0] * sin(l.Point[1]) * (2 * g.Parameters[0] * pow(E, l.FieldValues[1]) * g.Parameters[5] + pow(-1 + l.Point[0], 2) * l.DerivativeValues[0][2] + pow(-1 + l.Point[0], 2) * l.DerivativeValues[1][1] + l.DerivativeValues[2][1] - 2 * l.Point[0] * l.DerivativeValues[2][1] + pow(l.Point[0], 2) * l.DerivativeValues[2][1])) / (2. * g.Parameters[0]); });
    descriptor.SetJacobianComponent(4, 5, 0, 0, [](const auto& l, const auto& g) {return (sin(l.Point[1]) * (-4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] + 4 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0])) / (4. * pow(E, l.FieldValues[0])); });
    descriptor.SetJacobianComponent(4, 6, 0, 0, [](const auto& l, const auto& g) {return pow(E, l.FieldValues[1] - l.FieldValues[2]) * g.Parameters[4] - cos(l.Point[1]) / 2. + pow(E, l.FieldValues[1] - l.FieldValues[2]) * g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) - (sin(l.Point[1]) * (l.DerivativeValues[0][0] + l.DerivativeValues[1][3] + l.DerivativeValues[2][0])) / 2.; });
    descriptor.SetJacobianComponent(4, 7, 0, 0, [](const auto& l, const auto& g) {return (pow(E, -l.FieldValues[0] + l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * (-l.FieldValues[3] + (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) / g.Parameters[0])) / 4.; });
    descriptor.SetJacobianComponent(4, 8, 0, 0, [](const auto& l, const auto& g) {return pow(E, l.FieldValues[1]) * g.Parameters[3] * l.VIEValues[0] * sin(l.Point[1]) * (l.FieldValues[6] / pow(E, l.FieldValues[2]) - (sin(l.Point[1]) * l.FieldValues[3] * l.FieldValues[5]) / pow(E, l.FieldValues[0])); });
    descriptor.SetJacobianComponent(4, 9, 0, 0, [](const auto& l, const auto& g) {return -(pow(E, -l.FieldValues[0] + l.FieldValues[1]) * g.Parameters[3] * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[5]); });
    descriptor.SetJacobianComponent(4, 0, 1, 0, [](const auto& l, const auto& g) {return -0.5 * (l.FieldValues[6] * sin(l.Point[1])); });
    descriptor.SetJacobianComponent(4, 0, 3, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[4]) / (2. * g.Parameters[0]); });
    descriptor.SetJacobianComponent(4, 1, 2, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[4]) / (2. * g.Parameters[0]); });
    descriptor.SetJacobianComponent(4, 1, 4, 0, [](const auto& l, const auto& g) {return -0.5 * (l.FieldValues[6] * sin(l.Point[1])); });
    descriptor.SetJacobianComponent(4, 2, 1, 0, [](const auto& l, const auto& g) {return -0.5 * (l.FieldValues[6] * sin(l.Point[1])); });
    descriptor.SetJacobianComponent(4, 2, 2, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[4]) / (2. * g.Parameters[0]); });
    descriptor.SetJacobianComponent(4, 3, 1, 0, [](const auto& l, const auto& g) {return (pow(E, -l.FieldValues[0] + l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * l.FieldValues[5]) / 4.; });
    descriptor.SetJacobianComponent(4, 3, 2, 0, [](const auto& l, const auto& g) {return (pow(E, -l.FieldValues[0] + l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * l.FieldValues[7] * l.VIEValues[0] * pow(sin(l.Point[1]), 2)) / (4. * g.Parameters[0]); });
    descriptor.SetJacobianComponent(4, 4, 2, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1])) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(4, 6, 2, 0, [](const auto& l, const auto& g) {return -sin(l.Point[1]); });
    descriptor.SetJacobianComponent(4, 4, 2, 1, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(4, 4, 0, 2, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(4, 4, 0, 3, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(4, 4, 1, 4, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(5, 0, 0, 0, [](const auto& l, const auto& g) {return (sin(l.Point[1]) * (g.Parameters[0] * l.FieldValues[4] * (-4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] + 4 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) - pow(E, l.FieldValues[2]) * l.FieldValues[6] * sin(l.Point[1]) * (g.Parameters[0] * l.FieldValues[3] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]))) / (4. * g.Parameters[0] * pow(E, l.FieldValues[0])); });
    descriptor.SetJacobianComponent(5, 1, 0, 0, [](const auto& l, const auto& g) {return pow(E, l.FieldValues[1]) * ((l.FieldValues[7] * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]))) / pow(E, l.FieldValues[2]) + (sin(l.Point[1]) * (g.Parameters[4] * l.FieldValues[3] * l.FieldValues[4] + l.VIEValues[0] * ((-g.Parameters[2] + g.Parameters[3] * l.FieldValues[9] + g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) * l.FieldValues[4] - pow(E, l.FieldValues[0]) * g.Parameters[5] * l.FieldValues[5]))) / pow(E, l.FieldValues[0])); });
    descriptor.SetJacobianComponent(5, 2, 0, 0, [](const auto& l, const auto& g) {return -(pow(E, l.FieldValues[1] - l.FieldValues[2]) * l.FieldValues[7] * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]))) - (pow(E, -l.FieldValues[0] + l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * (g.Parameters[0] * l.FieldValues[4] * l.DerivativeValues[3][0] + l.FieldValues[6] * (-(g.Parameters[0] * l.FieldValues[3]) + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]))) / (4. * g.Parameters[0]); });
    descriptor.SetJacobianComponent(5, 3, 0, 0, [](const auto& l, const auto& g) {return (sin(l.Point[1]) * (pow(E, l.FieldValues[2]) * l.FieldValues[6] * sin(l.Point[1]) + 4 * pow(E, l.FieldValues[1]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[4])) / (4. * pow(E, l.FieldValues[0])); });
    descriptor.SetJacobianComponent(5, 4, 0, 0, [](const auto& l, const auto& g) {return (sin(l.Point[1]) * (4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] - 4 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0])) / (4. * pow(E, l.FieldValues[0])); });
    descriptor.SetJacobianComponent(5, 5, 0, 0, [](const auto& l, const auto& g) {return sin(l.Point[1]) * (1 - pow(E, l.FieldValues[1]) * g.Parameters[5] * l.VIEValues[0] + (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (l.DerivativeValues[0][2] + l.DerivativeValues[1][1] + l.DerivativeValues[2][1])) / (2. * g.Parameters[0])); });
    descriptor.SetJacobianComponent(5, 6, 0, 0, [](const auto& l, const auto& g) {return (pow(E, -l.FieldValues[0] + l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * (g.Parameters[0] * l.FieldValues[3] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1])) / (4. * g.Parameters[0]); });
    descriptor.SetJacobianComponent(5, 7, 0, 0, [](const auto& l, const auto& g) {return pow(E, l.FieldValues[1] - l.FieldValues[2]) * g.Parameters[4] - cos(l.Point[1]) / 2. + pow(E, l.FieldValues[1] - l.FieldValues[2]) * g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) - (sin(l.Point[1]) * (l.DerivativeValues[0][0] + l.DerivativeValues[1][3] + l.DerivativeValues[2][0])) / 2.; });
    descriptor.SetJacobianComponent(5, 8, 0, 0, [](const auto& l, const auto& g) {return -(pow(E, l.FieldValues[1]) * g.Parameters[3] * l.VIEValues[0] * sin(l.Point[1]) * (-(l.FieldValues[7] / pow(E, l.FieldValues[2])) - (sin(l.Point[1]) * l.FieldValues[3] * l.FieldValues[4]) / pow(E, l.FieldValues[0]))); });
    descriptor.SetJacobianComponent(5, 9, 0, 0, [](const auto& l, const auto& g) {return pow(E, -l.FieldValues[0] + l.FieldValues[1]) * g.Parameters[3] * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[4]; });
    descriptor.SetJacobianComponent(5, 0, 1, 0, [](const auto& l, const auto& g) {return -0.5 * (l.FieldValues[7] * sin(l.Point[1])); });
    descriptor.SetJacobianComponent(5, 0, 3, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[5]) / (2. * g.Parameters[0]); });
    descriptor.SetJacobianComponent(5, 1, 2, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[5]) / (2. * g.Parameters[0]); });
    descriptor.SetJacobianComponent(5, 1, 4, 0, [](const auto& l, const auto& g) {return -0.5 * (l.FieldValues[7] * sin(l.Point[1])); });
    descriptor.SetJacobianComponent(5, 2, 1, 0, [](const auto& l, const auto& g) {return -0.5 * (l.FieldValues[7] * sin(l.Point[1])); });
    descriptor.SetJacobianComponent(5, 2, 2, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[5]) / (2. * g.Parameters[0]); });
    descriptor.SetJacobianComponent(5, 3, 1, 0, [](const auto& l, const auto& g) {return -0.25 * (pow(E, -l.FieldValues[0] + l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * l.FieldValues[4]); });
    descriptor.SetJacobianComponent(5, 3, 2, 0, [](const auto& l, const auto& g) {return -0.25 * (pow(E, -l.FieldValues[0] + l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * l.FieldValues[6] * l.VIEValues[0] * pow(sin(l.Point[1]), 2)) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(5, 5, 2, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1])) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(5, 7, 2, 0, [](const auto& l, const auto& g) {return -sin(l.Point[1]); });
    descriptor.SetJacobianComponent(5, 5, 2, 1, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(5, 5, 0, 2, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(5, 5, 0, 3, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(5, 5, 1, 4, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(6, 0, 0, 0, [](const auto& l, const auto& g) {return -0.25 * (sin(l.Point[1]) * (g.Parameters[0] * l.FieldValues[7] * (4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] - 4 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[5] * (g.Parameters[0] * l.FieldValues[3] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]))) / (g.Parameters[0] * pow(E, l.FieldValues[0])); });
    descriptor.SetJacobianComponent(6, 1, 0, 0, [](const auto& l, const auto& g) {return pow(E, l.FieldValues[1]) * (-(g.Parameters[5] * l.FieldValues[6] * l.VIEValues[0] * sin(l.Point[1])) + (l.FieldValues[7] * sin(l.Point[1]) * (g.Parameters[4] * l.FieldValues[3] + l.VIEValues[0] * (-g.Parameters[2] + g.Parameters[3] * l.FieldValues[9] + g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]))) / pow(E, l.FieldValues[0]) + ((g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[4]) / pow(E, l.FieldValues[2])); });
    descriptor.SetJacobianComponent(6, 2, 0, 0, [](const auto& l, const auto& g) {return -(pow(E, l.FieldValues[1] - l.FieldValues[2]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[4]) + (pow(E, -l.FieldValues[0] + l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * (g.Parameters[0] * l.FieldValues[3] * l.FieldValues[5] + g.Parameters[0] * l.FieldValues[7] * l.DerivativeValues[3][0] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.FieldValues[5] * l.DerivativeValues[3][1])) / (4. * g.Parameters[0]); });
    descriptor.SetJacobianComponent(6, 3, 0, 0, [](const auto& l, const auto& g) {return (sin(l.Point[1]) * (4 * pow(E, l.FieldValues[1]) * l.FieldValues[7] * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[5])) / (4. * pow(E, l.FieldValues[0])); });
    descriptor.SetJacobianComponent(6, 4, 0, 0, [](const auto& l, const auto& g) {return (2 * pow(E, l.FieldValues[1] - l.FieldValues[2]) * g.Parameters[4] + cos(l.Point[1]) + 2 * pow(E, l.FieldValues[1] - l.FieldValues[2]) * g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) + sin(l.Point[1]) * (l.DerivativeValues[0][0] + l.DerivativeValues[1][3] + l.DerivativeValues[2][0])) / 2.; });
    descriptor.SetJacobianComponent(6, 5, 0, 0, [](const auto& l, const auto& g) {return (pow(E, -l.FieldValues[0] + l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * (l.FieldValues[3] - (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) / g.Parameters[0])) / 4.; });
    descriptor.SetJacobianComponent(6, 6, 0, 0, [](const auto& l, const auto& g) {return sin(l.Point[1]) * (1 - pow(E, l.FieldValues[1]) * g.Parameters[5] * l.VIEValues[0] + (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (l.DerivativeValues[0][2] + l.DerivativeValues[1][1] + l.DerivativeValues[2][1])) / (2. * g.Parameters[0])); });
    descriptor.SetJacobianComponent(6, 7, 0, 0, [](const auto& l, const auto& g) {return (sin(l.Point[1]) * (4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] - 4 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0])) / (4. * pow(E, l.FieldValues[0])); });
    descriptor.SetJacobianComponent(6, 8, 0, 0, [](const auto& l, const auto& g) {return pow(E, l.FieldValues[1]) * g.Parameters[3] * l.VIEValues[0] * sin(l.Point[1]) * ((l.FieldValues[7] * sin(l.Point[1]) * l.FieldValues[3]) / pow(E, l.FieldValues[0]) + l.FieldValues[4] / pow(E, l.FieldValues[2])); });
    descriptor.SetJacobianComponent(6, 9, 0, 0, [](const auto& l, const auto& g) {return pow(E, -l.FieldValues[0] + l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[7] * l.VIEValues[0] * sin(l.Point[1]); });
    descriptor.SetJacobianComponent(6, 0, 1, 0, [](const auto& l, const auto& g) {return (sin(l.Point[1]) * l.FieldValues[4]) / 2.; });
    descriptor.SetJacobianComponent(6, 0, 3, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.FieldValues[6] * l.VIEValues[0] * sin(l.Point[1])) / (2. * g.Parameters[0]); });
    descriptor.SetJacobianComponent(6, 1, 2, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.FieldValues[6] * l.VIEValues[0] * sin(l.Point[1])) / (2. * g.Parameters[0]); });
    descriptor.SetJacobianComponent(6, 1, 4, 0, [](const auto& l, const auto& g) {return (sin(l.Point[1]) * l.FieldValues[4]) / 2.; });
    descriptor.SetJacobianComponent(6, 2, 1, 0, [](const auto& l, const auto& g) {return (sin(l.Point[1]) * l.FieldValues[4]) / 2.; });
    descriptor.SetJacobianComponent(6, 2, 2, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.FieldValues[6] * l.VIEValues[0] * sin(l.Point[1])) / (2. * g.Parameters[0]); });
    descriptor.SetJacobianComponent(6, 3, 1, 0, [](const auto& l, const auto& g) {return (pow(E, -l.FieldValues[0] + l.FieldValues[2]) * l.FieldValues[7] * pow(sin(l.Point[1]), 2)) / 4.; });
    descriptor.SetJacobianComponent(6, 3, 2, 0, [](const auto& l, const auto& g) {return -0.25 * (pow(E, -l.FieldValues[0] + l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[5]) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(6, 4, 1, 0, [](const auto& l, const auto& g) {return sin(l.Point[1]); });
    descriptor.SetJacobianComponent(6, 6, 1, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1])) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(6, 6, 1, 1, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(6, 6, 0, 2, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(6, 6, 2, 3, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(6, 6, 0, 4, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(7, 0, 0, 0, [](const auto& l, const auto& g) {return (sin(l.Point[1]) * (g.Parameters[0] * l.FieldValues[6] * (4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] - 4 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[4] * (g.Parameters[0] * l.FieldValues[3] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]))) / (4. * g.Parameters[0] * pow(E, l.FieldValues[0])); });
    descriptor.SetJacobianComponent(7, 1, 0, 0, [](const auto& l, const auto& g) {return pow(E, l.FieldValues[1]) * (g.Parameters[5] * l.FieldValues[7] * l.VIEValues[0] * sin(l.Point[1]) - (l.FieldValues[6] * sin(l.Point[1]) * (g.Parameters[4] * l.FieldValues[3] + l.VIEValues[0] * (-g.Parameters[2] + g.Parameters[3] * l.FieldValues[9] + g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]))) / pow(E, l.FieldValues[0]) + ((g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[5]) / pow(E, l.FieldValues[2])); });
    descriptor.SetJacobianComponent(7, 2, 0, 0, [](const auto& l, const auto& g) {return (-4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[5] - 4 * pow(E, l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[5] - pow(E, -l.FieldValues[0] + 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * (l.FieldValues[6] * l.DerivativeValues[3][0] + l.FieldValues[4] * (l.FieldValues[3] - (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) / g.Parameters[0]))) / (4. * pow(E, l.FieldValues[2])); });
    descriptor.SetJacobianComponent(7, 3, 0, 0, [](const auto& l, const auto& g) {return -0.25 * (sin(l.Point[1]) * (4 * pow(E, l.FieldValues[1]) * l.FieldValues[6] * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[4])) / pow(E, l.FieldValues[0]); });
    descriptor.SetJacobianComponent(7, 4, 0, 0, [](const auto& l, const auto& g) {return -0.25 * (pow(E, -l.FieldValues[0] + l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * (l.FieldValues[3] - (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) / g.Parameters[0])); });
    descriptor.SetJacobianComponent(7, 5, 0, 0, [](const auto& l, const auto& g) {return (2 * pow(E, l.FieldValues[1] - l.FieldValues[2]) * g.Parameters[4] + cos(l.Point[1]) + 2 * pow(E, l.FieldValues[1] - l.FieldValues[2]) * g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1]) + sin(l.Point[1]) * (l.DerivativeValues[0][0] + l.DerivativeValues[1][3] + l.DerivativeValues[2][0])) / 2.; });
    descriptor.SetJacobianComponent(7, 6, 0, 0, [](const auto& l, const auto& g) {return -0.25 * (sin(l.Point[1]) * (4 * pow(E, l.FieldValues[1]) * g.Parameters[4] * l.FieldValues[3] - 4 * pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9] - g.Parameters[3] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3]) + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.DerivativeValues[3][0])) / pow(E, l.FieldValues[0]); });
    descriptor.SetJacobianComponent(7, 7, 0, 0, [](const auto& l, const auto& g) {return sin(l.Point[1]) + (l.VIEValues[0] * sin(l.Point[1]) * (2 * g.Parameters[0] * pow(E, l.FieldValues[1]) * g.Parameters[5] + pow(-1 + l.Point[0], 2) * l.DerivativeValues[0][2] + pow(-1 + l.Point[0], 2) * l.DerivativeValues[1][1] + l.DerivativeValues[2][1] - 2 * l.Point[0] * l.DerivativeValues[2][1] + pow(l.Point[0], 2) * l.DerivativeValues[2][1])) / (2. * g.Parameters[0]); });
    descriptor.SetJacobianComponent(7, 8, 0, 0, [](const auto& l, const auto& g) {return -(pow(E, l.FieldValues[1]) * g.Parameters[3] * l.VIEValues[0] * sin(l.Point[1]) * ((l.FieldValues[6] * sin(l.Point[1]) * l.FieldValues[3]) / pow(E, l.FieldValues[0]) - l.FieldValues[5] / pow(E, l.FieldValues[2]))); });
    descriptor.SetJacobianComponent(7, 9, 0, 0, [](const auto& l, const auto& g) {return -(pow(E, -l.FieldValues[0] + l.FieldValues[1]) * g.Parameters[3] * l.FieldValues[6] * l.VIEValues[0] * sin(l.Point[1])); });
    descriptor.SetJacobianComponent(7, 0, 1, 0, [](const auto& l, const auto& g) {return (sin(l.Point[1]) * l.FieldValues[5]) / 2.; });
    descriptor.SetJacobianComponent(7, 0, 3, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.FieldValues[7] * l.VIEValues[0] * sin(l.Point[1])) / (2. * g.Parameters[0]); });
    descriptor.SetJacobianComponent(7, 1, 2, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.FieldValues[7] * l.VIEValues[0] * sin(l.Point[1])) / (2. * g.Parameters[0]); });
    descriptor.SetJacobianComponent(7, 1, 4, 0, [](const auto& l, const auto& g) {return (sin(l.Point[1]) * l.FieldValues[5]) / 2.; });
    descriptor.SetJacobianComponent(7, 2, 1, 0, [](const auto& l, const auto& g) {return (sin(l.Point[1]) * l.FieldValues[5]) / 2.; });
    descriptor.SetJacobianComponent(7, 2, 2, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.FieldValues[7] * l.VIEValues[0] * sin(l.Point[1])) / (2. * g.Parameters[0]); });
    descriptor.SetJacobianComponent(7, 3, 1, 0, [](const auto& l, const auto& g) {return -0.25 * (pow(E, -l.FieldValues[0] + l.FieldValues[2]) * l.FieldValues[6] * pow(sin(l.Point[1]), 2)); });
    descriptor.SetJacobianComponent(7, 3, 2, 0, [](const auto& l, const auto& g) {return (pow(E, -l.FieldValues[0] + l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * l.FieldValues[4]) / (4. * g.Parameters[0]); });
    descriptor.SetJacobianComponent(7, 5, 1, 0, [](const auto& l, const auto& g) {return sin(l.Point[1]); });
    descriptor.SetJacobianComponent(7, 7, 1, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1])) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(7, 7, 1, 1, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(7, 7, 0, 2, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(7, 7, 2, 3, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(7, 7, 0, 4, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(8, 0, 0, 0, [](const auto& l, const auto& g) {return -2 * pow(E, -2 * l.FieldValues[0] + 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 3) * (l.FieldValues[8] * sin(l.Point[1]) * pow(l.FieldValues[3], 2) - l.FieldValues[8] * cos(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[3][0] - sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] * l.DerivativeValues[3][0] - l.DerivativeValues[9][0] * l.DerivativeValues[3][0] + (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * pow(l.FieldValues[3], 2) * l.DerivativeValues[8][1]) / g.Parameters[0] + (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.FieldValues[3] * l.DerivativeValues[9][1]) / g.Parameters[0] - (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (g.Parameters[0] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] + l.DerivativeValues[9][1])) * l.DerivativeValues[3][1]) / pow(g.Parameters[0], 2)); });
    descriptor.SetJacobianComponent(8, 1, 0, 0, [](const auto& l, const auto& g) {return -8 * pow(E, 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * (l.FieldValues[7] * l.FieldValues[4] - l.FieldValues[6] * l.FieldValues[5]); });
    descriptor.SetJacobianComponent(8, 2, 0, 0, [](const auto& l, const auto& g) {return 2 * pow(E, l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * (-2 * pow(E, 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * (l.FieldValues[7] * l.FieldValues[4] - l.FieldValues[6] * l.FieldValues[5]) + pow(E, -2 * l.FieldValues[0] + l.FieldValues[2]) * sin(l.Point[1]) * (l.FieldValues[8] * sin(l.Point[1]) * pow(l.FieldValues[3], 2) - l.FieldValues[8] * cos(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[3][0] - sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] * l.DerivativeValues[3][0] - l.DerivativeValues[9][0] * l.DerivativeValues[3][0] + (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * pow(l.FieldValues[3], 2) * l.DerivativeValues[8][1]) / g.Parameters[0] + (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.FieldValues[3] * l.DerivativeValues[9][1]) / g.Parameters[0] - (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (g.Parameters[0] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] + l.DerivativeValues[9][1])) * l.DerivativeValues[3][1]) / pow(g.Parameters[0], 2))); });
    descriptor.SetJacobianComponent(8, 3, 0, 0, [](const auto& l, const auto& g) {return pow(E, -2 * l.FieldValues[0] + 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 3) * (2 * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3] - l.FieldValues[8] * cos(l.Point[1]) * l.DerivativeValues[3][0] - sin(l.Point[1]) * l.DerivativeValues[8][0] * l.DerivativeValues[3][0] + (2 * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1]) / g.Parameters[0] + (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[9][1]) / g.Parameters[0] - (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * (g.Parameters[0] * l.FieldValues[8] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[8][1]) * l.DerivativeValues[3][1]) / pow(g.Parameters[0], 2)); });
    descriptor.SetJacobianComponent(8, 4, 0, 0, [](const auto& l, const auto& g) {return -4 * pow(E, 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[3] * l.FieldValues[7] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2); });
    descriptor.SetJacobianComponent(8, 5, 0, 0, [](const auto& l, const auto& g) {return 4 * pow(E, 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[3] * l.FieldValues[6] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2); });
    descriptor.SetJacobianComponent(8, 6, 0, 0, [](const auto& l, const auto& g) {return 4 * pow(E, 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[5]; });
    descriptor.SetJacobianComponent(8, 7, 0, 0, [](const auto& l, const auto& g) {return -4 * pow(E, 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * l.FieldValues[4]; });
    descriptor.SetJacobianComponent(8, 8, 0, 0, [](const auto& l, const auto& g) {return (-g.Parameters[0] + g.Parameters[0] * cos(l.Point[1]) * sin(l.Point[1]) * (l.DerivativeValues[0][0] - l.DerivativeValues[2][0]) + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * (l.DerivativeValues[0][2] - l.DerivativeValues[2][1]) + pow(E, -2 * l.FieldValues[0] + 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 3) * l.FieldValues[3] * (g.Parameters[0] * sin(l.Point[1]) * l.FieldValues[3] - g.Parameters[0] * cos(l.Point[1]) * l.DerivativeValues[3][0] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.DerivativeValues[3][1])) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(8, 0, 1, 0, [](const auto& l, const auto& g) {return sin(l.Point[1]) * (l.FieldValues[8] * cos(l.Point[1]) + sin(l.Point[1]) * l.DerivativeValues[8][0]); });
    descriptor.SetJacobianComponent(8, 0, 3, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * (g.Parameters[0] * l.FieldValues[8] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[8][1])) / pow(g.Parameters[0], 2); });
    descriptor.SetJacobianComponent(8, 2, 1, 0, [](const auto& l, const auto& g) {return -(sin(l.Point[1]) * (l.FieldValues[8] * cos(l.Point[1]) + sin(l.Point[1]) * l.DerivativeValues[8][0])); });
    descriptor.SetJacobianComponent(8, 2, 2, 0, [](const auto& l, const auto& g) {return -((pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * (g.Parameters[0] * l.FieldValues[8] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[8][1])) / pow(g.Parameters[0], 2)); });
    descriptor.SetJacobianComponent(8, 3, 1, 0, [](const auto& l, const auto& g) {return -(pow(E, -2 * l.FieldValues[0] + 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 3) * (l.FieldValues[8] * cos(l.Point[1]) * l.FieldValues[3] + sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] + l.DerivativeValues[9][0])); });
    descriptor.SetJacobianComponent(8, 3, 2, 0, [](const auto& l, const auto& g) {return -((pow(E, -2 * l.FieldValues[0] + 2 * l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 3) * (g.Parameters[0] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] + l.DerivativeValues[9][1]))) / pow(g.Parameters[0], 2)); });
    descriptor.SetJacobianComponent(8, 8, 1, 0, [](const auto& l, const auto& g) {return sin(l.Point[1]) * (cos(l.Point[1]) + sin(l.Point[1]) * (l.DerivativeValues[0][0] - l.DerivativeValues[2][0]) - pow(E, -2 * l.FieldValues[0] + 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 3) * l.FieldValues[3] * l.DerivativeValues[3][0]); });
    descriptor.SetJacobianComponent(8, 8, 2, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * (2 * g.Parameters[0] + 2 * (-1 + l.Point[0]) * l.VIEValues[0] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (l.DerivativeValues[0][2] - l.DerivativeValues[2][1]) + pow(E, -2 * l.FieldValues[0] + 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * (g.Parameters[0] * l.FieldValues[3] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]))) / pow(g.Parameters[0], 2); });
    descriptor.SetJacobianComponent(8, 8, 3, 0, [](const auto& l, const auto& g) {return pow(sin(l.Point[1]), 2); });
    descriptor.SetJacobianComponent(8, 8, 4, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 4) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2)) / pow(g.Parameters[0], 2); });
    descriptor.SetJacobianComponent(8, 9, 1, 0, [](const auto& l, const auto& g) {return -(pow(E, -2 * l.FieldValues[0] + 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 3) * l.DerivativeValues[3][0]); });
    descriptor.SetJacobianComponent(8, 9, 2, 0, [](const auto& l, const auto& g) {return (pow(E, -2 * l.FieldValues[0] + 2 * l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 3) * (g.Parameters[0] * l.FieldValues[3] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1])) / pow(g.Parameters[0], 2); });
    descriptor.SetJacobianComponent(8, 8, 0, 1, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(8, 8, 0, 2, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(8, 8, 0, 3, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(8, 8, 0, 4, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(9, 0, 0, 0, [](const auto& l, const auto& g) {return 2 * pow(E, l.FieldValues[0] + 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * (pow(l.FieldValues[6], 2) + pow(l.FieldValues[7], 2) + pow(l.FieldValues[4], 2) + pow(l.FieldValues[5], 2)) - 2 * pow(E, -2 * l.FieldValues[0] + 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 4) * l.FieldValues[3] * (-(l.FieldValues[8] * sin(l.Point[1]) * pow(l.FieldValues[3], 2)) + l.FieldValues[8] * cos(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[3][0] + sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] * l.DerivativeValues[3][0] + l.DerivativeValues[9][0] * l.DerivativeValues[3][0] - (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * pow(l.FieldValues[3], 2) * l.DerivativeValues[8][1]) / g.Parameters[0] - (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.FieldValues[3] * l.DerivativeValues[9][1]) / g.Parameters[0] + (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (g.Parameters[0] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] + l.DerivativeValues[9][1])) * l.DerivativeValues[3][1]) / pow(g.Parameters[0], 2)); });
    descriptor.SetJacobianComponent(9, 1, 0, 0, [](const auto& l, const auto& g) {return 4 * pow(E, 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * (2 * pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[3] * (l.FieldValues[7] * l.FieldValues[4] - l.FieldValues[6] * l.FieldValues[5]) + pow(E, l.FieldValues[0]) * (pow(l.FieldValues[6], 2) + pow(l.FieldValues[7], 2) + pow(l.FieldValues[4], 2) + pow(l.FieldValues[5], 2))); });
    descriptor.SetJacobianComponent(9, 2, 0, 0, [](const auto& l, const auto& g) {return 2 * pow(E, l.FieldValues[2]) * pow(sin(l.Point[1]), 3) * l.FieldValues[3] * (2 * pow(E, 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * (l.FieldValues[7] * l.FieldValues[4] - l.FieldValues[6] * l.FieldValues[5]) + pow(E, -2 * l.FieldValues[0] + l.FieldValues[2]) * sin(l.Point[1]) * (-(l.FieldValues[8] * sin(l.Point[1]) * pow(l.FieldValues[3], 2)) + l.FieldValues[8] * cos(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[3][0] + sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] * l.DerivativeValues[3][0] + l.DerivativeValues[9][0] * l.DerivativeValues[3][0] - (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * pow(l.FieldValues[3], 2) * l.DerivativeValues[8][1]) / g.Parameters[0] - (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.FieldValues[3] * l.DerivativeValues[9][1]) / g.Parameters[0] + (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (g.Parameters[0] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] + l.DerivativeValues[9][1])) * l.DerivativeValues[3][1]) / pow(g.Parameters[0], 2))); });
    descriptor.SetJacobianComponent(9, 3, 0, 0, [](const auto& l, const auto& g) {return (sin(l.Point[1]) * (8 * pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[1] + l.FieldValues[2]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * (l.FieldValues[7] * l.FieldValues[4] - l.FieldValues[6] * l.FieldValues[5]) + g.Parameters[0] * l.FieldValues[8] * (3 * g.Parameters[0] + g.Parameters[0] * cos(2 * l.Point[1]) + 2 * g.Parameters[0] * sin(2 * l.Point[1]) * l.DerivativeValues[2][0] - 4 * sin(l.Point[1]) * (g.Parameters[0] * cos(l.Point[1]) * l.DerivativeValues[0][0] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * (l.DerivativeValues[0][2] - l.DerivativeValues[2][1]))) + 2 * sin(l.Point[1]) * (2 * pow(g.Parameters[0], 2) * l.DerivativeValues[8][0] * (cos(l.Point[1]) + sin(l.Point[1]) * (-l.DerivativeValues[0][0] + l.DerivativeValues[2][0])) + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.DerivativeValues[8][1] * (g.Parameters[0] - 2 * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[0][2] + 2 * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[2][1])) - 2 * pow(E, -2 * l.FieldValues[0] + 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 3) * l.FieldValues[3] * (2 * pow(g.Parameters[0], 2) * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3] - pow(g.Parameters[0], 2) * l.FieldValues[8] * cos(l.Point[1]) * l.DerivativeValues[3][0] - pow(g.Parameters[0], 2) * sin(l.Point[1]) * l.DerivativeValues[8][0] * l.DerivativeValues[3][0] + 2 * g.Parameters[0] * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] + g.Parameters[0] * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[9][1] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * (g.Parameters[0] * l.FieldValues[8] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[8][1]) * l.DerivativeValues[3][1]) - 2 * pow(E, -2 * l.FieldValues[0] + 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 3) * (pow(g.Parameters[0], 2) * l.FieldValues[8] * sin(l.Point[1]) * pow(l.FieldValues[3], 2) - pow(g.Parameters[0], 2) * l.FieldValues[8] * cos(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[3][0] - pow(g.Parameters[0], 2) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] * l.DerivativeValues[3][0] - pow(g.Parameters[0], 2) * l.DerivativeValues[9][0] * l.DerivativeValues[3][0] + g.Parameters[0] * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * pow(l.FieldValues[3], 2) * l.DerivativeValues[8][1] + g.Parameters[0] * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.FieldValues[3] * l.DerivativeValues[9][1] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (sin(l.Point[1]) * l.FieldValues[3] * (g.Parameters[0] * l.FieldValues[8] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[8][1]) + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[9][1]) * l.DerivativeValues[3][1]))) / (2. * pow(g.Parameters[0], 2)); });
    descriptor.SetJacobianComponent(9, 4, 0, 0, [](const auto& l, const auto& g) {return 4 * pow(E, 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * (pow(E, l.FieldValues[2]) * l.FieldValues[7] * sin(l.Point[1]) * l.FieldValues[3] + pow(E, l.FieldValues[0]) * l.FieldValues[4]); });
    descriptor.SetJacobianComponent(9, 5, 0, 0, [](const auto& l, const auto& g) {return -4 * pow(E, 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * (pow(E, l.FieldValues[2]) * l.FieldValues[6] * sin(l.Point[1]) * l.FieldValues[3] - pow(E, l.FieldValues[0]) * l.FieldValues[5]); });
    descriptor.SetJacobianComponent(9, 6, 0, 0, [](const auto& l, const auto& g) {return 4 * pow(E, 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * (pow(E, l.FieldValues[0]) * l.FieldValues[6] - pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[3] * l.FieldValues[5]); });
    descriptor.SetJacobianComponent(9, 7, 0, 0, [](const auto& l, const auto& g) {return 4 * pow(E, 2 * l.FieldValues[1]) * g.Parameters[3] * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2) * (pow(E, l.FieldValues[0]) * l.FieldValues[7] + pow(E, l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[3] * l.FieldValues[4]); });
    descriptor.SetJacobianComponent(9, 8, 0, 0, [](const auto& l, const auto& g) {return (sin(l.Point[1]) * (sin(2 * l.Point[1]) * l.DerivativeValues[3][0] + l.FieldValues[3] * (3 + cos(2 * l.Point[1]) + 2 * sin(2 * l.Point[1]) * l.DerivativeValues[2][0] - (4 * sin(l.Point[1]) * (g.Parameters[0] * cos(l.Point[1]) * l.DerivativeValues[0][0] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * (l.DerivativeValues[0][2] - l.DerivativeValues[2][1]))) / g.Parameters[0]))) / 2. + (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 3) * l.DerivativeValues[3][1]) / g.Parameters[0] - (pow(E, -2 * l.FieldValues[0] + 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 4) * pow(l.FieldValues[3], 2) * (g.Parameters[0] * sin(l.Point[1]) * l.FieldValues[3] - g.Parameters[0] * cos(l.Point[1]) * l.DerivativeValues[3][0] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * sin(l.Point[1]) * l.DerivativeValues[3][1])) / g.Parameters[0]; });
    descriptor.SetJacobianComponent(9, 0, 1, 0, [](const auto& l, const auto& g) {return -(pow(sin(l.Point[1]), 2) * (2 * l.FieldValues[8] * cos(l.Point[1]) * l.FieldValues[3] + 2 * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] + l.DerivativeValues[9][0])); });
    descriptor.SetJacobianComponent(9, 0, 3, 0, [](const auto& l, const auto& g) {return -((pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * (2 * g.Parameters[0] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (2 * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] + l.DerivativeValues[9][1]))) / pow(g.Parameters[0], 2)); });
    descriptor.SetJacobianComponent(9, 2, 1, 0, [](const auto& l, const auto& g) {return sin(l.Point[1]) * (l.FieldValues[8] * sin(2 * l.Point[1]) * l.FieldValues[3] + sin(l.Point[1]) * (2 * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] + l.DerivativeValues[9][0])); });
    descriptor.SetJacobianComponent(9, 2, 2, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * (2 * g.Parameters[0] * l.FieldValues[8] * sin(l.Point[1]) * l.FieldValues[3] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (2 * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][1] + l.DerivativeValues[9][1]))) / pow(g.Parameters[0], 2); });
    descriptor.SetJacobianComponent(9, 3, 1, 0, [](const auto& l, const auto& g) {return (l.FieldValues[8] * sin(l.Point[1]) * sin(2 * l.Point[1])) / 2. + pow(sin(l.Point[1]), 3) * l.DerivativeValues[8][0] + pow(E, -2 * l.FieldValues[0] + 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 4) * l.FieldValues[3] * (l.FieldValues[8] * cos(l.Point[1]) * l.FieldValues[3] + sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[8][0] + l.DerivativeValues[9][0]); });
    descriptor.SetJacobianComponent(9, 3, 2, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 3) * (g.Parameters[0] * l.FieldValues[8] * (pow(E, 2 * l.FieldValues[0]) + pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2)) + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * ((pow(E, 2 * l.FieldValues[0]) + pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2)) * l.DerivativeValues[8][1] + pow(E, 2 * l.FieldValues[2]) * sin(l.Point[1]) * l.FieldValues[3] * l.DerivativeValues[9][1]))) / (pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[0])); });
    descriptor.SetJacobianComponent(9, 8, 1, 0, [](const auto& l, const auto& g) {return pow(sin(l.Point[1]), 2) * (2 * l.FieldValues[3] * (cos(l.Point[1]) + sin(l.Point[1]) * (-l.DerivativeValues[0][0] + l.DerivativeValues[2][0])) + sin(l.Point[1]) * l.DerivativeValues[3][0] + pow(E, -2 * l.FieldValues[0] + 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 3) * pow(l.FieldValues[3], 2) * l.DerivativeValues[3][0]); });
    descriptor.SetJacobianComponent(9, 8, 2, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 3) * (-(g.Parameters[0] * pow(E, 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 3)) + pow(E, 2 * l.FieldValues[0]) * l.FieldValues[3] * (g.Parameters[0] - 2 * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * (l.DerivativeValues[0][2] - l.DerivativeValues[2][1])) + pow(E, 2 * l.FieldValues[0]) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1] + pow(E, 2 * l.FieldValues[2]) * pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * pow(l.FieldValues[3], 2) * l.DerivativeValues[3][1])) / (pow(g.Parameters[0], 2) * pow(E, 2 * l.FieldValues[0])); });
    descriptor.SetJacobianComponent(9, 9, 1, 0, [](const auto& l, const auto& g) {return sin(l.Point[1]) * (cos(l.Point[1]) + sin(l.Point[1]) * (-l.DerivativeValues[0][0] + l.DerivativeValues[2][0]) + pow(E, -2 * l.FieldValues[0] + 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 3) * l.FieldValues[3] * l.DerivativeValues[3][0]); });
    descriptor.SetJacobianComponent(9, 9, 2, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 2) * l.VIEValues[0] * pow(sin(l.Point[1]), 2) * (2 * g.Parameters[0] + 2 * (-1 + l.Point[0]) * l.VIEValues[0] - pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[0][2] + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[2][1] + pow(E, -2 * l.FieldValues[0] + 2 * l.FieldValues[2]) * pow(sin(l.Point[1]), 2) * l.FieldValues[3] * (-(g.Parameters[0] * l.FieldValues[3]) + pow(-1 + l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]))) / pow(g.Parameters[0], 2); });
    descriptor.SetJacobianComponent(9, 9, 3, 0, [](const auto& l, const auto& g) {return pow(sin(l.Point[1]), 2); });
    descriptor.SetJacobianComponent(9, 9, 4, 0, [](const auto& l, const auto& g) {return (pow(-1 + l.Point[0], 4) * pow(l.VIEValues[0], 2) * pow(sin(l.Point[1]), 2)) / pow(g.Parameters[0], 2); });
    descriptor.SetJacobianComponent(9, 9, 2, 1, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(9, 9, 0, 2, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(9, 9, 1, 3, [](const auto& l, const auto& g) {return 1; });
    descriptor.SetJacobianComponent(9, 9, 1, 4, [](const auto& l, const auto& g) {return 1; });

    auto grid = std::make_shared<DirectProductGrid<2, double>>(SingleDimensionalGrid<double>({MakeUniformRange<double>(0, 1, 100), std::nullopt}), SingleDimensionalGrid<double>({MakeUniformRange<double>(0 + 1e-10, Pi - 1e-10, 100), std::nullopt}));
    auto discretization = std::make_unique<StructuredFiniteDifferenceDiscretization<2>>(5);
    auto problem = descriptor.MakeProblem<CSRMatrix>(grid, std::move(discretization));
    problem->AddIntegralOutputExpression([](const auto& l, const auto& g) { return (g.Parameters[0] * pow(E, -l.FieldValues[0] + l.FieldValues[1]) * Pi * l.VIEValues[0] * sin(l.Point[1]) * (-8 * pow(E, 2 * l.FieldValues[0] + l.FieldValues[1]) * (g.Parameters[4] * csc(l.Point[1]) + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0]) * (l.FieldValues[7] * l.FieldValues[4] - l.FieldValues[6] * l.FieldValues[5]) + pow(E, 2 * l.FieldValues[2]) * (8 * pow(E, l.FieldValues[1]) * sin(l.Point[1]) * l.FieldValues[3] * (-(g.Parameters[2] * l.VIEValues[0]) + g.Parameters[3] * l.VIEValues[0] * l.FieldValues[9] + (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[3]) * (l.FieldValues[7] * l.FieldValues[4] - l.FieldValues[6] * l.FieldValues[5]) + pow(E, l.FieldValues[0]) * (pow(l.FieldValues[6], 2) * (2 * l.FieldValues[3] * (cos(l.Point[1]) + sin(l.Point[1]) * (-l.DerivativeValues[0][0] + l.DerivativeValues[2][0])) + sin(l.Point[1]) * l.DerivativeValues[3][0]) + pow(l.FieldValues[7], 2) * (2 * l.FieldValues[3] * (cos(l.Point[1]) + sin(l.Point[1]) * (-l.DerivativeValues[0][0] + l.DerivativeValues[2][0])) + sin(l.Point[1]) * l.DerivativeValues[3][0]) - (pow(l.FieldValues[4], 2) + pow(l.FieldValues[5], 2)) * (2 * l.FieldValues[3] * (cos(l.Point[1]) + sin(l.Point[1]) * (-l.DerivativeValues[0][0] + l.DerivativeValues[2][0])) + sin(l.Point[1]) * l.DerivativeValues[3][0]) + 2 * l.FieldValues[6] * sin(l.Point[1]) * l.FieldValues[4] * (l.FieldValues[3] * (-1 + (2 * pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[0][2]) / g.Parameters[0] - (2 * pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[2][1]) / g.Parameters[0]) - (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) / g.Parameters[0]) + 2 * l.FieldValues[7] * sin(l.Point[1]) * l.FieldValues[5] * (l.FieldValues[3] * (-1 + (2 * pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[0][2]) / g.Parameters[0] - (2 * pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[2][1]) / g.Parameters[0]) - (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[3][1]) / g.Parameters[0]))) + 4 * pow(E, l.FieldValues[0] + l.FieldValues[2]) * (-(pow(E, l.FieldValues[1]) * l.VIEValues[0] * (g.Parameters[2] - g.Parameters[3] * l.FieldValues[9]) * (pow(l.FieldValues[6], 2) + pow(l.FieldValues[7], 2) + pow(l.FieldValues[4], 2) + pow(l.FieldValues[5], 2))) - pow(E, l.FieldValues[0]) * (l.FieldValues[7] * (l.DerivativeValues[4][0] + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[6][0]) / g.Parameters[0]) - l.FieldValues[6] * (l.DerivativeValues[5][0] + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[7][0]) / g.Parameters[0]) + l.FieldValues[5] * (l.DerivativeValues[6][1] - (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[4][1]) / g.Parameters[0]) + l.FieldValues[4] * (-l.DerivativeValues[7][1] + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[5][1]) / g.Parameters[0]))))) / pow(1 - l.Point[0], 2); }, "M");
    problem->AddIntegralOutputExpression([](const auto& l, const auto& g) { return (g.Parameters[0] * pow(E, -l.FieldValues[0] + l.FieldValues[1] + l.FieldValues[2]) * Pi * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * (2 * pow(E, l.FieldValues[0] + l.FieldValues[1]) * (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * (pow(l.FieldValues[6], 2) + pow(l.FieldValues[7], 2) + pow(l.FieldValues[4], 2) + pow(l.FieldValues[5], 2)) + pow(E, l.FieldValues[2]) * (-4 * pow(E, l.FieldValues[1]) * sin(l.Point[1]) * (-(g.Parameters[2] * l.VIEValues[0]) + g.Parameters[3] * l.VIEValues[0] * l.FieldValues[9] + (g.Parameters[4] + g.Parameters[3] * l.FieldValues[8] * l.VIEValues[0] * sin(l.Point[1])) * l.FieldValues[3]) * (l.FieldValues[7] * l.FieldValues[4] - l.FieldValues[6] * l.FieldValues[5]) + pow(E, l.FieldValues[0]) * (-(pow(l.FieldValues[6], 2) * (cos(l.Point[1]) + sin(l.Point[1]) * (-l.DerivativeValues[0][0] + l.DerivativeValues[2][0]))) - pow(l.FieldValues[7], 2) * (cos(l.Point[1]) + sin(l.Point[1]) * (-l.DerivativeValues[0][0] + l.DerivativeValues[2][0])) + (pow(l.FieldValues[4], 2) + pow(l.FieldValues[5], 2)) * (cos(l.Point[1]) + sin(l.Point[1]) * (-l.DerivativeValues[0][0] + l.DerivativeValues[2][0])) + 2 * l.FieldValues[6] * sin(l.Point[1]) * l.FieldValues[4] * (1 - (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[0][2]) / g.Parameters[0] + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[2][1]) / g.Parameters[0]) + 2 * l.FieldValues[7] * sin(l.Point[1]) * l.FieldValues[5] * (1 - (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[0][2]) / g.Parameters[0] + (pow(1 - l.Point[0], 2) * l.VIEValues[0] * l.DerivativeValues[2][1]) / g.Parameters[0]))))) / pow(1 - l.Point[0], 2); }, "J");
    problem->AddIntegralOutputExpression([](const auto& l, const auto& g) { return (4 * g.Parameters[0] * pow(E, 2 * l.FieldValues[1] + l.FieldValues[2]) * Pi * pow(l.VIEValues[0], 2) * sin(l.Point[1]) * (pow(l.FieldValues[6], 2) + pow(l.FieldValues[7], 2) + pow(l.FieldValues[4], 2) + pow(l.FieldValues[5], 2))) / pow(1 - l.Point[0], 2); }, "Q");
    problem->AddPointOutputExpression({ 1, 1.5708 }, [](const auto& l, const auto& g) { return (4 * g.Parameters[0] * Pi * l.DerivativeValues[0][2]) / pow(g.Parameters[1], 2); }, "Minf");
    problem->AddPointOutputExpression({ 1, 1.5708 }, [](const auto& l, const auto& g) { return (pow(g.Parameters[0], 2) * Pi * l.DerivativeValues[3][3]) / pow(g.Parameters[1], 2); }, "Jinf");
    problem->AddPointOutputExpression({ 1, 1.5708 }, [](const auto& l, const auto& g) { return 4 * g.Parameters[0] * Pi * l.DerivativeValues[9][1]; }, "Qinf");
    problem->AddPointOutputExpression({ 1, 1.5708 }, [](const auto& l, const auto& g) { return (pow(g.Parameters[0], 2) * l.DerivativeValues[8][3]) / 2.; }, "g");

    std::fstream source(R"(D:\Workspace\FermiMaxwell\output\q=0.95\1_n=0.500000_con=0.500000,alp=1.000000,w=0.902008,q=0.950000,mu=1.000000\vars.dat)");
    Vector<double> initial(problem->DOFCount());
    for (auto& value : initial)
    {
        source >> value;
    }
    source.close();

    problem->SetParameters({ 0.5, 1, 0.901280, 0.95, 0.5, 1 });
    problem->SetVariables(initial);

    auto pardiso = std::make_unique<MKL::PARDISO<double>>();
    auto gss = MakeLineSearcher<GoldenSectionSearch>(*problem);
    auto newton = MakeNonlinearSolver<ModifiedNewton>(*problem, std::move(pardiso), std::move(gss));
    newton->SetMeritGoal(1e-7);
    newton->SetIterationLimit(20);
    //newton->Solve(*problem);
    //auto sweeper = FixedStepParametricSweeper(problem, std::move(newton), 2, 0.901, 0.9, 0.0001);
    auto sweeper = AdaptiveParametricSweeper(problem, std::move(newton), 2, 0.902, 0., -1e-3);
    sweeper.SetMinStep(1e-4);
    sweeper.Sweep();

    Serializer::Save(*problem, R"(D:/Workspace/CESDSOL-testing/fermiTest.dat)");

    /*auto grid1 = DirectProductGrid{
        SingleDimensionalGrid<double>{MakeUniformRange(0., 10., 1000) }
    };

    auto descriptor = StationaryProblemDescriptor<1, double, \
        double>(GridDescriptor<1, double>(3), Array<Array<std::array<size_t, \
            1>>>{ { {2}}}, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0);
    descriptor.SetProblemName("SineGordon");
    descriptor.SetParameterName(0, "g");
    descriptor.SetVariableName(0, "f");
    descriptor.SetContinuousEquation(0, 0, [](const auto& locals, const \
        auto& globals) {return \
        globals.Parameters[0] * sin(locals.FieldValues[0]) + \
        locals.DerivativeValues[0][0]; });
    descriptor.SetContinuousEquation(0, 1, [](const auto& locals, const \
        auto& globals) {return -Pi + locals.FieldValues[0]; });
    descriptor.SetContinuousEquation(0, 2, [](const auto& locals, const \
        auto& globals) {return -2 * Pi + locals.FieldValues[0]; });
    descriptor.SetJacobianComponent(0, 0, 0, 0, [](const auto& locals, \
        const auto& globals) {return \
        globals.Parameters[0] * cos(locals.FieldValues[0]); });
    descriptor.SetJacobianComponent(0, 0, 1, 0, [](const auto& locals, \
        const auto& globals) {return 1; });
    descriptor.SetJacobianComponent(0, 0, 0, 1, [](const auto& locals, \
        const auto& globals) {return 1; });
    descriptor.SetJacobianComponent(0, 0, 0, 2, [](const auto& locals, \
        const auto& globals) {return 1; });

    auto problem = descriptor.MakeProblem(grid1, StructuredFiniteDifferenceDiscretization<1>(5));
    problem->SetVariables(Transform<double>(grid1.GetGrid(0), [](auto x) {return 4 * atan(exp(x)); }));
    problem->SetParameter(0, -1);
    
    auto pardiso = std::make_unique<MKL::PARDISO<double>>();
    auto gss = MakeLineSearcher<GoldenSectionSearch>(*problem);
    auto newton = MakeNonlinearSolver<ModifiedNewton>(*problem, std::move(pardiso), std::move(gss));
    newton->Solve(*problem);
    Serializer::Save(*problem, R"(D:/Workspace/CESDSOL-testing/test.dat)");*/
	
    /*auto descriptor = ExplicitTransientProblemDescriptor<1, double, double>(grid1.GetDescriptor(), { 2 }, { { 2 } }, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0);
    descriptor.SetProblemName("SineGordon");
    descriptor.SetParameterName(0, "g");
	descriptor.SetContinuousEquation(0, 0, 
        [](const auto& localValues, const auto& globalValues)
        {
	        return localValues.DerivativeValues[0][0] - sin(localValues.FieldValues[0]) * globalValues.Parameters[0];
        });
	descriptor.SetContinuousEquation(0, 1, [](const auto& localValues, const auto& globalValues)
        {
            return localValues.FieldValues[0] - 0;
        });
    descriptor.SetContinuousEquation(0, 2, [](const auto& localValues, const auto& globalValues)
        {
            return localValues.FieldValues[0] - 2 * Pi;
        });

    auto problem = descriptor.MakeProblem(grid1, StructuredFiniteDifferenceDiscretization<1>(5));
    double v = 0.5, t = 1, gamma = 1 / sqrt(1 - v * v);
    auto kink = Transform<double>(grid1.GetGrid(0), [=](auto x) {return 4 * atan(exp(gamma * x)); });
	auto kink1 = Transform<double>(grid1.GetGrid(0), [=](auto x) {return 4 * atan(exp(gamma * (x - v * t))); });
    problem->SetVariable(0, kink);
    problem->SetVariable(1, Transform<double>(grid1.GetGrid(0), [=](auto x) {return -4 * exp(gamma * x) * gamma * v / (1 + exp(2 * gamma * x)); }));
    problem->SetParameter(0, 1);
	
    auto rk = RungeKuttaSolver<Verner87, double, double, true, true>();
    rk.SetAbsoluteTolerance(1e-8);
    rk.SetRelativeTolerance(1e-8);
    rk.Solve(0, t, *problem);
    AXPY(-1, problem->GetCache().GetPrevious(t)->get()[0], kink1);
    std::cout << Norm2(kink1);*/

    /*auto descriptor = StationaryProblemDescriptor<2, double, \
        double>(GridDescriptor<2, double>(5), Array<Array<std::array<size_t, \
            2>>>{ { {2, 0}}, { {1, 1} }}, 2, 1, 2);
    descriptor.SetProblemName("TestProblem");
    descriptor.SetParameterName(0, "q");
    descriptor.SetVariableName(0, "f");
    descriptor.SetVariableName(1, "g");
    descriptor.SetVariableName(2, "p");
    descriptor.SetVariableName(3, "t");
    descriptor.SetContinuousEquation(0, 0, [](const auto& locals, const \
        auto& globals) {return pow(locals.FieldValues[1], 3) + \
        sin(locals.FieldValues[0]) + \
        globals.DiscreteVariables[0] * locals.DerivativeValues[1][0] + \
        globals.Parameters[0] * locals.DerivativeValues[0][0]; });
    descriptor.SetContinuousEquation(1, 0, [](const auto& locals, const \
        auto& globals) {return locals.FieldValues[1]; });
    descriptor.SetDiscreteEquation(0, [](const auto& globals) {return \
        globals.DiscreteVariables[0] - globals.Parameters[0]; });
    descriptor.SetDiscreteEquation(1, [](const auto& globals) {return \
        globals.Parameters[0] + \
        globals.DiscreteVariables[0] * globals.DiscreteVariables[1]; });
    descriptor.SetJacobianComponent(0, 0, 0, 0, [](const auto& locals, \
        const auto& globals) {return cos(locals.FieldValues[0]); });
    descriptor.SetJacobianComponent(0, 1, 0, 0, [](const auto& locals, \
        const auto& globals) {return 3 * pow(locals.FieldValues[1], 2); });
    descriptor.SetJacobianComponent(0, 2, 0, 0, [](const auto& locals, \
        const auto& globals) {return locals.DerivativeValues[1][0]; });
    descriptor.SetJacobianComponent(0, 0, 1, 0, [](const auto& locals, \
        const auto& globals) {return globals.Parameters[0]; });
    descriptor.SetJacobianComponent(0, 1, 1, 0, [](const auto& locals, \
        const auto& globals) {return globals.DiscreteVariables[0]; });
    descriptor.SetJacobianComponent(1, 1, 0, 0, [](const auto& locals, \
        const auto& globals) {return 1; });
    descriptor.SetJacobianComponent(2, 2, 0, 0, [](const auto& locals, \
        const auto& globals) {return 1; });
    descriptor.SetJacobianComponent(3, 2, 0, 0, [](const auto& locals, \
        const auto& globals) {return globals.DiscreteVariables[1]; });
    descriptor.SetJacobianComponent(3, 3, 0, 0, [](const auto& locals, \
        const auto& globals) {return globals.DiscreteVariables[0]; });*/
	
//    auto grid1 = DirectProductGrid{
//    	SingleDimensionalGrid<double>{MakeUniformRange(0., 10., 101) },
//        SingleDimensionalGrid<double>{MakeUniformRange(0., 10., 101) }
//    };
//    //std::cout << StructuredFiniteDifferenceDiscretization<1>(5).GetDifferentiationMatrix(grid1, 2);
//	
//#define fEquation Equation(0)
//#define hEquation Equation(1)
//#define x Direction(0)
//#define y Direction(1)
//#define Left LeftBoundary(x)
//#define Right RightBoundary(x)
//#define Bottom LeftBoundary(y)
//#define Top RightBoundary(y)
//#define f Field(0)
//#define h Field(1)
//#define dxx(field) DerivativeOperator(field, 0)
//#define dyy(field) DerivativeOperator(field, 1)
//#define dx(field) DerivativeOperator(field, 2)
//#define dy(field) DerivativeOperator(field, 3)
//#define g Parameter(0)
//
//    auto descriptor = StationaryProblemDescriptor<2, double, double>(grid1.GetDescriptor(), { {2, 0}, {0, 2}, {1, 0}, {0, 1} }, 2, 1, 1, 0, 0, 0, 0, 1, 0, 1);
//    descriptor.SetProblemName("TestProblem");
//    descriptor.SetParameterName(0, "g");
//	
//	descriptor.SetIntegrand(0, std::function([](const LocalValues<2>& SimplifiedInterfaceLocalsHelper, const GlobalValues<>& SimplifiedInterfaceGlobalsHelper) 
//        {return f; }));
//    descriptor.SetIntegrandJacobianComponent(0, 0, 0, std::function([](const LocalValues<2>& SimplifiedInterfaceLocalsHelper, const GlobalValues<>& SimplifiedInterfaceGlobalsHelper) {return 1; }));
//
//	descriptor.SetLocalVariableDependentExpression(0, std::function([](const LocalValues<2>& SimplifiedInterfaceLocalsHelper, const GlobalValues<>& SimplifiedInterfaceGlobalsHelper)
//        {return g * f * h; }));
//	descriptor.SetLocalVariableDependentExpressionJacobianComponent(0, 0, 0, std::function([](const LocalValues<2>& SimplifiedInterfaceLocalsHelper, const GlobalValues<>& SimplifiedInterfaceGlobalsHelper)
//        {return g * h; }));
//    descriptor.SetLocalVariableDependentExpressionJacobianComponent(0, 1, 0, std::function([](const LocalValues<2>& SimplifiedInterfaceLocalsHelper, const GlobalValues<>& SimplifiedInterfaceGlobalsHelper)
//        {return g * f; }));
//	
//    AddFieldEquation(descriptor, fEquation, Interior, dxx(f) - sin(f) - SimplifiedInterfaceLocalsHelper.VDEValues[0]);
//    AddFieldEquation(descriptor, fEquation, Left, f - Pi);
//    AddFieldEquation(descriptor, fEquation, Right, f - 2 * Pi);
//    AddFieldEquation(descriptor, fEquation, Top, dy(f));
//    AddFieldEquation(descriptor, fEquation, Bottom, dy(f));
//    SetJacobian(descriptor, fEquation, f, Interior, -cos(f) - SimplifiedInterfaceLocalsHelper.LVDEJacobianComponentValues[0][0][0]);
//    SetJacobian(descriptor, fEquation, h, Interior, -SimplifiedInterfaceLocalsHelper.LVDEJacobianComponentValues[0][1][0]);
//    SetJacobian(descriptor, fEquation, dxx(f), Interior, 1);
//    SetJacobian(descriptor, fEquation, f, Left, 1);
//    SetJacobian(descriptor, fEquation, f, Right, 1);
//    SetJacobian(descriptor, fEquation, dy(f), Top, 1);
//    SetJacobian(descriptor, fEquation, dy(f), Bottom, 1);
//	
//    AddFieldEquation(descriptor, hEquation, Interior, dyy(h) - sin(h) - SimplifiedInterfaceLocalsHelper.VDEValues[0]);
//    AddFieldEquation(descriptor, hEquation, Bottom, h - Pi);
//    AddFieldEquation(descriptor, hEquation, Top, h - 2 * Pi);
//    SetJacobian(descriptor, hEquation, h, Interior, -cos(h) - SimplifiedInterfaceLocalsHelper.LVDEJacobianComponentValues[0][1][0]);
//    SetJacobian(descriptor, hEquation, f, Interior, -SimplifiedInterfaceLocalsHelper.LVDEJacobianComponentValues[0][0][0]);
//    SetJacobian(descriptor, hEquation, dyy(h), Interior, 1);
//    SetJacobian(descriptor, hEquation, h, Bottom, 1);
//    SetJacobian(descriptor, hEquation, h, Top, 1);
//
//    descriptor.SetDiscreteEquation(0, [](const auto& globals) { return globals.DiscreteVariables[0] - globals.ReductionValues[0]; });
//    descriptor.SetJacobianComponent(2, 0, 0, 0, [](const auto& locals, const auto& globals) { return -locals.ReductionJacobianComponentValues[0][0][0]; });
//	descriptor.SetJacobianComponent(2, 2, 0, 0, [](const auto& locals, const auto& globals) { return 1; });
//	
//    /*descriptor.SetEquation(0, 0, [](const auto& locals, const auto& globals) {return -std::sin(locals.FieldValues[0]) + locals.DerivativeValues[0][0]; });
//    descriptor.SetEquation(0, 1, [](const auto& locals, const auto& globals) {return locals.FieldValues[0]; });
//    descriptor.SetEquation(0, 2, [](const auto& locals, const auto& globals) {return locals.FieldValues[0] - 2 * 3.1415; });
//    descriptor.SetJacobianComponent(0, 0, 0, 0, [](const auto& locals, const auto& globals) {return -std::cos(locals.FieldValues[0]); });
//    descriptor.SetJacobianComponent(0, 0, 1, 0, [](const auto& locals, const auto& globals) {return 1; });
//    descriptor.SetJacobianComponent(0, 0, 0, 1, [](const auto& locals, const auto& globals) {return 1; });
//    descriptor.SetJacobianComponent(0, 0, 0, 2, [](const auto& locals, const auto& globals) {return 1; });*/
//    //std::cout << descriptor;
//
//    auto problem = descriptor.MakeProblem(grid1, StructuredFiniteDifferenceDiscretization<2>(5));
//    //Serializer::Load(problem, R"(D:/Workspace/CESDSOL-testing/test.dat)");
//    problem->SetVariables(Array(2 * 3.1415, problem->DOFCount()));
//    problem->SetParameter(0, 0.0);
//	
//    auto pardiso = std::make_unique<MKL::PARDISO<double>>();
//    auto ilu0 = std::make_unique<MKL::ILU0>();
//    auto ilut = std::make_unique<MKL::ILUT>();
//    auto fgmres = std::make_unique<MKL::FGMRES<CSRMatrix<double>>>();
//    fgmres->SetPreconditioner(std::move(ilut));
//    auto gss = MakeLineSearcher<GoldenSectionSearch>(*problem);
//    auto tls = MakeLineSearcher<TrivialLineSearcher>(*problem);
//    auto newton = MakeNonlinearSolver<ModifiedNewton>(*problem, std::move(fgmres), std::move(gss));
//    //problem.PrintJacobianStructure(std::cout);
//    //std::cout << problem.GetJacobian();
//    //newton.Solve(problem);
//
//    auto sweeper = FixedStepParametricSweeper(problem, std::move(newton), 0., 0., 0.01, 0.01);
//    sweeper.Sweep();
//
//    /*const auto& result = problem.GetVariables();
//    auto expected1 = Apply(grid1, [](auto var) {return 4 * std::atan(std::exp(var[0])); });
//    auto expected2 = Apply(grid1, [](auto var) {return 4 * std::atan(std::exp(var[1])); });
//    AXPY(-1, result[0], expected1);
//    AXPY(-1, result[1], expected2);
//    std::cout << Norm2(expected1) << '\n';
//    std::cout << Norm2(expected2) << '\n';
//    std::cout << result[2][0];*/
//    /*for (size_t i = 0; i < 101; ++i)
//	{
//        std::cout << expected[3 * i] << '\n';
//	}*/
//
//    //Serializer::Save(problem, R"(D:/Workspace/CESDSOL-testing/test.dat)");
}

// Run program: Ctrl + F5 or Debug > Start Without Debugging menu
// Debug program: F5 or Debug > Start Debugging menu

// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file
